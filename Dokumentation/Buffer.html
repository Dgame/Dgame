<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.System.Buffer</title>
        </head><body>
        <h1>Dgame.System.Buffer</h1>
        <!-- Generated by Ddoc from C:\Users\Besitzer\Documents\GitHub\Dgame\System\Buffer.d -->
<br><br>
<dl><dt><big><a name="Usage"></a>abstract class <u>Usage</u>;
</big></dt>
<dd><u>Usage</u> methods<br><br>

<dl><dt><big><a name="Usage.Stream"></a>enum <u>Stream</u>;
</big></dt>
<dd><u>Stream</u> usage<br><br>

<dl><dt><big><a name="Usage.Stream.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is determined once by the application
 and rarely used as the source for GL rendering command.<br><br>

</dd>
<dt><big><a name="Usage.Stream.Read"></a><u>Read</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and rarely queried by the application.<br><br>

</dd>
<dt><big><a name="Usage.Stream.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and rarely used as the source for GL rendering command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Usage.Static"></a>enum <u>Static</u>;
</big></dt>
<dd><u>Static</u> usage.<br><br>

<dl><dt><big><a name="Usage.Static.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is determined once by the application
 and often used as a source for a GL rendering command.<br><br>

</dd>
<dt><big><a name="Usage.Static.Read"></a><u>Read</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and often queried by the application.<br><br>

</dd>
<dt><big><a name="Usage.Static.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and often used as a source for a GL rendering command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Usage.Dynamic"></a>enum <u>Dynamic</u>;
</big></dt>
<dd><u>Dynamic</u> usage.<br><br>

<dl><dt><big><a name="Usage.Dynamic.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is repeatedly determined by the application
 and often used as a source for a GL rendering command.<br><br>

</dd>
<dt><big><a name="Usage.Dynamic.Read"></a><u>Read</u></big></dt>
<dd>The content of the data memory is repeatedly set for reading out data
 and frequently requested by the application.<br><br>

</dd>
<dt><big><a name="Usage.Dynamic.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is set repeatedly for reading data
 and often used as a source for a GL rendering command.<br><br>

</dd>
</dl>
</dd>
</dl>
</dd>
<dt><big><a name="Buffer"></a>class <u>Buffer</u>;
</big></dt>
<dd><u>Buffer</u> is a object oriented wrapper for a Vertex <u>Buffer</u> Object.
 VertexRenderer is public imported. See there for more details, like PointerTarget.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Buffer.Access"></a>enum <u>Access</u>;
</big></dt>
<dd>The access type.<br><br>

<dl><dt><big><a name="Buffer.Access.Read"></a><u>Read</u></big></dt>
<dd><u>Read</u> only. <br><br>

</dd>
<dt><big><a name="Buffer.Access.Write"></a><u>Write</u></big></dt>
<dd><u>Write</u> only. <br><br>

</dd>
<dt><big><a name="Buffer.Access.ReadWrite"></a><u>ReadWrite</u></big></dt>
<dd>Read and write. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Type"></a>enum <u>Type</u>;
</big></dt>
<dd>Declare which Buffer <u>Type</u> is stored.<br><br>

<dl><dt><big><a name="Buffer.Type.Array"></a><u>Array</u></big></dt>
<dd>The currently bound buffer object stores vertex array data. <br><br>

</dd>
<dt><big><a name="Buffer.Type.Element"></a><u>Element</u></big></dt>
<dd>The currently bound buffer object stores index values ​​for vertex arrays. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.this"></a> this(Primitive.Target <i>trg</i>, Type <i>type</i> = Type.Array);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Buffer.bind"></a>void <u>bind</u>(Primitive.Target <i>trg</i>);
</big></dt>
<dd>Binds the a specific VBO PointerTarget.
 If the target is invalid (because no such buffer exist)
 nothing happens.
<br><br>
<b>See:</b><br>
PointerTarget enum<br><br>

</dd>
<dt><big><a name="Buffer.unbind"></a>void <u>unbind</u>();
</big></dt>
<dd>Unbind the current VBO.<br><br>

</dd>
<dt><big><a name="Buffer.getBound"></a>const pure nothrow Primitive.Target <u>getBound</u>();
</big></dt>
<dd>Returns the current PointerTarget
<br><br>
<b>See:</b><br>
PointerTarget enum<br><br>

</dd>
<dt><big><a name="Buffer.isSomethingBound"></a>const pure nothrow bool <u>isSomethingBound</u>();
</big></dt>
<dd>Returns if some PointerTarget is currently bound<br><br>

</dd>
<dt><big><a name="Buffer.isCurrentEmpty"></a>const pure nothrow bool <u>isCurrentEmpty</u>();
</big></dt>
<dd>Checks whether the current buffer has already content, or not<br><br>

</dd>
<dt><big><a name="Buffer.isEmpty"></a>const bool <u>isEmpty</u>(Primitive.Target <i>trg</i>);
</big></dt>
<dd>Checks whether a specific buffer has already content, or not.
 If the target is invalid (because no such buffer exist)
 an Exception is thrown.<br><br>

</dd>
<dt><big><a name="Buffer.deplete"></a>void <u>deplete</u>();
</big></dt>
<dd>Reset the current buffer state
<br><br>
<b>See:</b><br>
isEmpty<br><br>

</dd>
<dt><big><a name="Buffer.depleteAll"></a>void <u>depleteAll</u>();
</big></dt>
<dd>Reset all buffer states
<br><br>
<b>See:</b><br>
isEmpty<br><br>

</dd>
<dt><big><a name="Buffer.cache"></a>void <u>cache</u>(const void* <i>ptr</i>, size_t <i>totalSize</i>, uint <i>usage</i> = Usage.Static.Draw);
</big></dt>
<dd>Stores data in the current VBO.
<br><br>
<b>See:</b><br>
glBufferData<br><br>

</dd>
<dt><big><a name="Buffer.modify"></a>const void <u>modify</u>(const void* <i>ptr</i>, size_t <i>totalSize</i>, uint <i>offset</i> = 0);
</big></dt>
<dd>Modify existing buffer data
<br><br>
<b>See:</b><br>
glBufferSubData<br><br>

</dd>
<dt><big><a name="Buffer.map"></a>const void* <u>map</u>(Access <i>access</i>);
</big></dt>
<dd>The internal buffer memory is transferred to the memory of the client
 with a specific <i>access</i>.
 Before the buffer can be reused, <code>unmap</code> must be called.
<br><br>
<b>See:</b><br>
Access enum
<br><br>
<b>See:</b><br>
glMapBuffer<br><br>

</dd>
<dt><big><a name="Buffer.unmap"></a>const void <u>unmap</u>();
</big></dt>
<dd>Allows other commands buffer access, in which it retrieves the memory from the client.
<br><br>
<b>See:</b><br>
map method<br><br>

</dd>
<dt><big><a name="Buffer.pointTo"></a>void <u>pointTo</u>(Primitive.Target <i>trg</i>, ubyte <i>stride</i> = 0, ubyte <i>offset</i> = 0);
</big></dt>
<dd>Points to the current VBO with a specific PointerTarget.
<br><br>
<b>See:</b><br>
glVertexPointer
<br><br>
<b>See:</b><br>
glColorPointer
<br><br>
<b>See:</b><br>
glTexCoordPointer
<br><br>
<b>See:</b><br>
PointerTarget enum.<br><br>

</dd>
<dt><big><a name="Buffer.enableState"></a>const void <u>enableState</u>(Primitive.Target <i>trg</i>);
</big></dt>
<dd>Enable a specific client state (with glEnableClientState)
 like GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
 with the corresponding PointerTarget.<br><br>

</dd>
<dt><big><a name="Buffer.enableAllStates"></a>const void <u>enableAllStates</u>();
</big></dt>
<dd>Enable all client states<br><br>

</dd>
<dt><big><a name="Buffer.disableAllStates"></a>const void <u>disableAllStates</u>();
</big></dt>
<dd>Disable all client states<br><br>

</dd>
<dt><big><a name="Buffer.disableState"></a>const void <u>disableState</u>(Primitive.Target <i>trg</i>);
</big></dt>
<dd>Disable a specific client state (with glDisableClientState)<br><br>

</dd>
<dt><big><a name="Buffer.drawArrays"></a>const void <u>drawArrays</u>(Primitive.Type <i>ptype</i>, size_t <i>count</i>, uint <i>start</i> = 0);
</big></dt>
<dd>Draw shapes of the specific type from the current VBO data.
 It will use <i>count</i> vertices.<br><br>

</dd>
<dt><big><a name="Buffer.drawElements"></a>const void <u>drawElements</u>(Primitive.Type <i>ptype</i>, size_t <i>count</i>, int[] <i>indices</i>);
</big></dt>
<dd>Draw shapes of the specific type from the current VBO data.
 It will use <i>count</i> vertices and <i>indices</i> for the correct index per vertex.<br><br>

</dd>
<dt><big><a name="Buffer.drawRangeElements"></a>const void <u>drawRangeElements</u>(Primitive.Type <i>ptype</i>, size_t <i>count</i>, int[] <i>indices</i>, int <i>start</i> = -1, int <i>end</i> = -1);
</big></dt>
<dd>Draw shapes of the specific type from the current VBO data.
 It will use <i>count</i> vertices and <i>indices</i> for the correct index per vertex.
<br><br>
<b>Note:</b><br>
If <i>start</i> or <i>end</i> are -1 or below, 0 and <i>indices</i>.length are used.<br><br>

</dd>
<dt><big><a name="Buffer.bindTexture"></a>void <u>bindTexture</u>(const Texture <i>tex</i>);
</big></dt>
<dd>Bind a texture to this Buffer.
 It's a shortcut for:
<pre class="d_code">buf.pointTo(Primitive.Target.TexCoords);
buf.pointTo(Primitive.Target.Vertex);

<i>tex</i>.bind();
</pre>
<br><br>
<b>Note:</b><br>
You should clean up with:
 <i>tex</i>.unbind(); and buf.disableAllStates();<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
