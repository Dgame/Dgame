<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.System.Buffer</title>
        </head><body>
        <h1>Dgame.System.Buffer</h1>
        <!-- Generated by Ddoc from System\Buffer.d -->
<br><br>
<dl><dt><big><a name="Buffer"></a>class <u>Buffer</u>;
</big></dt>
<dd><u>Buffer</u> is a object oriented wrapper for a Vertex <u>Buffer</u> Object.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Buffer.Type"></a>enum <u>Type</u>;
</big></dt>
<dd>Declare which Buffer <u>Type</u> is stored.<br><br>

<dl><dt><big><a name="Buffer.Type.Array"></a><u>Array</u></big></dt>
<dd>The currently bound buffer object stores vertex array data. <br><br>

</dd>
<dt><big><a name="Buffer.Type.Element"></a><u>Element</u></big></dt>
<dd>The currently bound buffer object stores index values ​​for vertex arrays. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Access"></a>enum <u>Access</u>;
</big></dt>
<dd>The access type.<br><br>

<dl><dt><big><a name="Buffer.Access.Read"></a><u>Read</u></big></dt>
<dd><u>Read</u> only. <br><br>

</dd>
<dt><big><a name="Buffer.Access.Write"></a><u>Write</u></big></dt>
<dd><u>Write</u> only. <br><br>

</dd>
<dt><big><a name="Buffer.Access.ReadWrite"></a><u>ReadWrite</u></big></dt>
<dd>Read and write. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Stream"></a>enum <u>Stream</u>;
</big></dt>
<dd><u>Stream</u> usage<br><br>

<dl><dt><big><a name="Buffer.Stream.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is determined once by the application
 and rarely used as the source for GL rendering command.<br><br>

</dd>
<dt><big><a name="Buffer.Stream.Read"></a><u>Read</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and rarely queried by the application.<br><br>

</dd>
<dt><big><a name="Buffer.Stream.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and rarely used as the source for GL rendering command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Static"></a>enum <u>Static</u>;
</big></dt>
<dd><u>Static</u> usage.<br><br>

<dl><dt><big><a name="Buffer.Static.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is determined once by the application
 and often used as a source for a GL rendering command.<br><br>

</dd>
<dt><big><a name="Buffer.Static.Read"></a><u>Read</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and often queried by the application.<br><br>

</dd>
<dt><big><a name="Buffer.Static.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is determined once for reading data
 and often used as a source for a GL rendering command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Dynamic"></a>enum <u>Dynamic</u>;
</big></dt>
<dd><u>Dynamic</u> usage.<br><br>

<dl><dt><big><a name="Buffer.Dynamic.Draw"></a><u>Draw</u></big></dt>
<dd>The contents of the data memory is repeatedly determined by the application
 and often used as a source for a GL rendering command.<br><br>

</dd>
<dt><big><a name="Buffer.Dynamic.Read"></a><u>Read</u></big></dt>
<dd>The content of the data memory is repeatedly set for reading out data
 and frequently requested by the application.<br><br>

</dd>
<dt><big><a name="Buffer.Dynamic.Copy"></a><u>Copy</u></big></dt>
<dd>The contents of the data memory is set repeatedly for reading data
 and often used as a source for a GL rendering command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.Target"></a>enum <u>Target</u>;
</big></dt>
<dd>Declare which data is stored. Possible are Vertices, Colors or Texture coordinates.<br><br>

<dl><dt><big><a name="Buffer.Target.None"></a><u>None</u></big></dt>
<dd>Declare that the data consist of nothing relevant. <br><br>

</dd>
<dt><big><a name="Buffer.Target.Vertex"></a><u>Vertex</u></big></dt>
<dd>Declare that the data consist of vertices. <br><br>

</dd>
<dt><big><a name="Buffer.Target.Color"></a><u>Color</u></big></dt>
<dd>Declare that the data consist of colors. <br><br>

</dd>
<dt><big><a name="Buffer.Target.TexCoords"></a><u>TexCoords</u></big></dt>
<dd>Declare that the data consist of texture coordinates. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Buffer.this"></a> this(Target <i>trg</i>, Type <i>type</i> = Type.Array);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Buffer.bind"></a>void <u>bind</u>(Target <i>trg</i>);
</big></dt>
<dd>Binds the a specific VBO Target.
 Now the specific VBO can be used.
<br><br>
<b>See:</b><br>
Target enum<br><br>

</dd>
<dt><big><a name="Buffer.getBound"></a>const pure nothrow Target <u>getBound</u>();
</big></dt>
<dd>Returns the current Target
<br><br>
<b>See:</b><br>
Target enum<br><br>

</dd>
<dt><big><a name="Buffer.isSomethingBound"></a>const pure nothrow bool <u>isSomethingBound</u>();
</big></dt>
<dd>Returns if some Target is currently bound<br><br>

</dd>
<dt><big><a name="Buffer.isEmpty"></a>const pure nothrow bool <u>isEmpty</u>();
</big></dt>
<dd>Checks whether the current buffer has already content, or not<br><br>

</dd>
<dt><big><a name="Buffer.deplete"></a>void <u>deplete</u>();
</big></dt>
<dd>Reset the current buffer state
<br><br>
<b>See:</b><br>
isEmpty<br><br>

</dd>
<dt><big><a name="Buffer.unbind"></a>void <u>unbind</u>();
</big></dt>
<dd>Unbind the current VBO.<br><br>

</dd>
<dt><big><a name="Buffer.cache"></a>void <u>cache</u>(const void* <i>ptr</i>, size_t <i>totalSize</i>, uint <i>usage</i> = (Static).Draw);
</big></dt>
<dd>Stores data in the current VBO.
<br><br>
<b>See:</b><br>
glBufferData<br><br>

</dd>
<dt><big><a name="Buffer.cache"></a>void <u>cache</u>(const Vertex[] <i>vertices</i>, uint <i>usage</i> = (Static).Draw);
</big></dt>
<dd>Stores vertex data<br><br>

</dd>
<dt><big><a name="Buffer.modify"></a>const void <u>modify</u>(const void* <i>ptr</i>, size_t <i>totalSize</i>, size_t <i>offset</i> = 0);
</big></dt>
<dd>Modify existing buffer data
<br><br>
<b>See:</b><br>
glBufferSubData<br><br>

</dd>
<dt><big><a name="Buffer.map"></a>const void* <u>map</u>(Access <i>access</i>);
</big></dt>
<dd>The internal buffer memory is transferred to the memory of the client
 with a specific <i>access</i>.
 Before the buffer can be reused, <code>unmap</code> must be called.
<br><br>
<b>See:</b><br>
Access enum
<br><br>
<b>See:</b><br>
glMapBuffer<br><br>

</dd>
<dt><big><a name="Buffer.unmap"></a>const void <u>unmap</u>();
</big></dt>
<dd>Allows other commands buffer access, in which it retrieves the memory from the client.
<br><br>
<b>See:</b><br>
map method<br><br>

</dd>
<dt><big><a name="Buffer.pointTo"></a>void <u>pointTo</u>(Target <i>trg</i>);
</big></dt>
<dd>Points to the current VBO with a specific Target.
<br><br>
<b>See:</b><br>
glVertexPointer
<br><br>
<b>See:</b><br>
glColorPointer
<br><br>
<b>See:</b><br>
glTexCoordPointer
<br><br>
<b>See:</b><br>
Target enum.<br><br>

</dd>
<dt><big><a name="Buffer.enableState"></a>void <u>enableState</u>(Target <i>trg</i>);
</big></dt>
<dd>Enable a specific client state (with glEnableClientState)
 like GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
 with the corresponding Target.<br><br>

</dd>
<dt><big><a name="Buffer.enableAllStates"></a>void <u>enableAllStates</u>();
</big></dt>
<dd>Enable all client states<br><br>

</dd>
<dt><big><a name="Buffer.disableAllStates"></a>void <u>disableAllStates</u>();
</big></dt>
<dd>Disable all client states<br><br>

</dd>
<dt><big><a name="Buffer.disableState"></a>void <u>disableState</u>(Target <i>trg</i>);
</big></dt>
<dd>Disable a specific client state (with glDisableClientState)<br><br>

</dd>
<dt><big><a name="Buffer.drawArrays"></a>const void <u>drawArrays</u>(GLenum <i>type</i>, size_t <i>count</i>);
</big></dt>
<dd>Draw shapes of the specific <i>type</i> from the current VBO data.
 It will use <i>count</i> vertices.<br><br>

</dd>
<dt><big><a name="Buffer.drawElements"></a>const void <u>drawElements</u>(GLenum <i>type</i>, size_t <i>count</i>, int[] <i>indices</i>);
</big></dt>
<dd>Draw shapes of the specific <i>type</i> from the current VBO data.
 It will use <i>count</i> vertices and <i>indices</i> for the correct index per vertex.<br><br>

</dd>
<dt><big><a name="Buffer.drawRangeElements"></a>const void <u>drawRangeElements</u>(GLenum <i>type</i>, size_t <i>count</i>, int[] <i>indices</i>);
</big></dt>
<dd>Draw shapes of the specific <i>type</i> from the current VBO data.
 It will use <i>count</i> vertices and <i>indices</i> for the correct index per vertex.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
