<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Math.Rect</title>
        </head><body>
        <h1>Dgame.Math.Rect</h1>
        <!-- Generated by Ddoc from Math\Rect.d -->
<br><br>
<dl><dt><big><a name="Rect"></a>struct <u>Rect</u>(T) if (isNumeric!T);
</big></dt>
<dd><u>Rect</u> defines a rectangle structure that contains the left upper corner and the width/height.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="x"></a>T <u>x</u>;
</big></dt>
<dd>The <u>x</u> and y coordinates<br><br>

</dd>
<dt><big><a name="width"></a>T <u>width</u>;
</big></dt>
<dd>The <u>width</u> and the height<br><br>

</dd>
<dt><big><a name="this"></a> this(T <i>x</i>, T <i>y</i>, T <i>width</i>, T <i>height</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="this"></a> this(ref const Vector2!T <i>vec</i>, T <i>width</i>, T <i>height</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="this"></a> this(U)(ref const Rect!U <i>rect</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="opAssign"></a>void <u>opAssign</u>(ref const Rect!T <i>rhs</i>);
</big></dt>
<dd><u>opAssign</u><br><br>

</dd>
<dt><big><a name="ptr"></a>const SDL_Rect* <u>ptr</u>();
</big></dt>
<dd>Returns a pointer to the inner SDL_Rect.<br><br>

</dd>
<dt><big><a name="opBinary"></a>const pure nothrow Rect!T <u>opBinary</u>(string op)(ref const Rect!T <i>rect</i>);
</big></dt>
<dd>Supported operations: +=, -=, *=, /=, %=<br><br>

</dd>
<dt><big><a name="collapse"></a>pure nothrow void <u>collapse</u>();
</big></dt>
<dd>Collapse this Rect. Means that the coordinates and the size is set to 0.<br><br>

</dd>
<dt><big><a name="isEmpty"></a>const bool <u>isEmpty</u>();
</big></dt>
<dd>Checks if this Rect is empty (if it's collapsed) with SDL_RectEmpty.<br><br>

</dd>
<dt><big><a name="hasArea"></a>const pure nothrow bool <u>hasArea</u>();
</big></dt>
<dd>Checks if this Rect is empty (if it's collapsed).<br><br>

</dd>
<dt><big><a name="getUnion"></a>const Rect!T <u>getUnion</u>(ref const Rect!T <i>rect</i>);
</big></dt>
<dd>Returns an union of the given and this Rect.<br><br>

</dd>
<dt><big><a name="opBinaryRight"></a>const pure nothrow bool <u>opBinaryRight</u>(string op)(ref Vector2!T <i>vec</i>) if (op == "in");
</big></dt>
<dd>Checks whether this Rect contains the given coordinates.<br><br>

</dd>
<dt><big><a name="contains"></a>const pure nothrow bool <u>contains</u>(ref const Vector2!T <i>vec</i>);
</big></dt>
<dd>Checks whether this Rect <u>contains</u> the given coordinates.<br><br>

</dd>
<dt><big><a name="contains"></a>const pure nothrow bool <u>contains</u>(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Checks whether this Rect <u>contains</u> the given coordinates.<br><br>

</dd>
<dt><big><a name="opEquals"></a>const bool <u>opEquals</u>(ref const Rect!T <i>rect</i>);
</big></dt>
<dd><b>opEquals:</b><br>
compares two rectangles on their coordinates and their size (but not explicit type).<br><br>

</dd>
<dt><big><a name="opCast"></a>const pure nothrow Rect!U <u>opCast</u>(V : Rect!U, U)();
</big></dt>
<dd><u>opCast</u> to another Rect type.<br><br>

</dd>
<dt><big><a name="intersects"></a>const bool <u>intersects</u>(ref const Rect!T <i>rect</i>, Rect!short* <i>overlap</i> = null);
</big></dt>
<dd>Checks whether this Rect <u>intersects</u> with an other.
 If, and the parameter '<i>overlap</i>' isn't <b>null</b>,
 the colliding rectangle is stored there.<br><br>

</dd>
<dt><big><a name="enclosePoints"></a>Rect!T <u>enclosePoints</u>(const Vector2!T[] <i>points</i>);
</big></dt>
<dd>Use this function to calculate a minimal rectangle enclosing a set of <i>points</i>.<br><br>

</dd>
<dt><big><a name="setSize"></a>pure nothrow void <u>setSize</u>(T <i>width</i>, T <i>height</i>);
</big></dt>
<dd>Replace current size.<br><br>

</dd>
<dt><big><a name="getSizeAsArray"></a>const pure nothrow T[2] <u>getSizeAsArray</u>();
</big></dt>
<dd>Returns the size (width and height) as static array.<br><br>

</dd>
<dt><big><a name="increase"></a>pure nothrow void <u>increase</u>(T <i>width</i>, T <i>height</i>);
</big></dt>
<dd>Increase current size.<br><br>

</dd>
<dt><big><a name="setPosition"></a>pure nothrow void <u>setPosition</u>(T[2] <i>pos</i>);
</big></dt>
<dd>Set a new position with an array.<br><br>

</dd>
<dt><big><a name="setPosition"></a>pure nothrow void <u>setPosition</u>(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Set a new position with coordinates.<br><br>

</dd>
<dt><big><a name="setPosition"></a>pure nothrow void <u>setPosition</u>(ref const Vector2!T <i>position</i>);
</big></dt>
<dd>Set a new <i>position</i> with a vector.<br><br>

</dd>
<dt><big><a name="getPositionAsArray"></a>const pure nothrow T[2] <u>getPositionAsArray</u>();
</big></dt>
<dd>Returns the position as static array.<br><br>

</dd>
<dt><big><a name="getPositionAsVector"></a>const pure nothrow Vector2!T <u>getPositionAsVector</u>();
</big></dt>
<dd>Creates a Vector2!T and returns thereby the current position.<br><br>

</dd>
<dt><big><a name="move"></a>pure nothrow void <u>move</u>(ref const Vector2!T <i>vec</i>);
</big></dt>
<dd>Move the object.<br><br>

</dd>
<dt><big><a name="move"></a>pure nothrow void <u>move</u>(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Move the object.<br><br>

</dd>
<dt><big><a name="set"></a>pure nothrow void <u>set</u>(T <i>x</i>, T <i>y</i>, T <i>w</i>, T <i>h</i>);
</big></dt>
<dd>The new coordinates <b>and</b> a new size.<br><br>

</dd>
<dt><big><a name="asArray"></a>const pure nothrow T[4] <u>asArray</u>();
</big></dt>
<dd>Returns the coordinates as static array<br><br>

</dd>
<dt><big><a name="distanceX"></a>const pure nothrow T <u>distanceX</u>();
</big></dt>
<dd>Calculate and returns the x distance, also called side a.<br><br>

</dd>
<dt><big><a name="distanceY"></a>const pure nothrow T <u>distanceY</u>();
</big></dt>
<dd>Calculate and returns the y distance, also called side b.<br><br>

</dd>
<dt><big><a name="getArea"></a>const pure nothrow T <u>getArea</u>();
</big></dt>
<dd>Calculate and returns the size of the area.<br><br>

</dd>
<dt><big><a name="getExtent"></a>const pure nothrow T <u>getExtent</u>();
</big></dt>
<dd>Calculate and return the size of the extent.<br><br>

</dd>
<dt><big><a name="diagonal"></a>const pure nothrow float <u>diagonal</u>();
</big></dt>
<dd>Calculate and returns the <u>diagonal</u> distance.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="FloatRect"></a>alias <u>FloatRect</u> = Rect!float.Rect;
</big></dt>
<dd>alias for float<br><br>

</dd>
<dt><big><a name="ShortRect"></a>alias <u>ShortRect</u> = Rect!short.Rect;
</big></dt>
<dd>alias for short<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
