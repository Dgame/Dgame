<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Texture</title>
        </head><body>
        <h1>Dgame.Graphics.Texture</h1>
        <!-- Generated by Ddoc from Graphics\Texture.d -->
<br><br>
<dl><dt><big><a name="formatToBits"></a>pure ubyte <u>formatToBits</u>(Texture.Format <i>fmt</i>);
</big></dt>
<dd>Format a Texture.Format into the related bit count.
 If the format is not supported, it returns 0.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGBA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGB) == 24);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGRA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGR) == 24);
</pre>
<br><br>

</dd>
<dt><big><a name="bitsToFormat"></a>pure Texture.Format <u>bitsToFormat</u>(ubyte <i>bits</i>, bool <i>reverse</i> = false);
</big></dt>
<dd>Format a bit count into the related Texture.Format.
 If no bit count is supported, it returns Texture.Format.None.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>bitsToFormat</u>(32) == Texture.Format.RGBA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24) == Texture.Format.RGB);
<font color=blue>assert</font>(<u>bitsToFormat</u>(32, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24, <font color=blue>true</font>) == Texture.Format.BGR);
</pre>
<br><br>

</dd>
<dt><big><a name="switchFormat"></a>pure Texture.Format <u>switchFormat</u>(Texture.Format <i>fmt</i>, bool <i>alpha</i> = false);
</big></dt>
<dd>Switch/Reverse Texture.Format.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB) == Texture.Format.BGR);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA, <font color=blue>true</font>) == Texture.Format.BGRA);
</pre>
<br><br>

</dd>
<dt><big><a name="Texture"></a>class <u>Texture</u>: Dgame.Graphics.Template.Blendable.Blendable;
</big></dt>
<dd>A <u>Texture</u> is a 2 dimensional pixel reprasentation.
 It is a wrapper of an OpenGL <u>Texture</u>.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Texture.Format"></a>enum <u>Format</u>;
</big></dt>
<dd>Supported Texture <u>Format</u><br><br>

<dl><dt><big><a name="Texture.Format.None"></a><u>None</u></big></dt>
<dd>Take this if you want to declare that you give no Format. <br><br>

</dd>
<dt><big><a name="Texture.Format.RGB"></a><u>RGB</u></big></dt>
<dd>Alias for GL_RGB <br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA"></a><u>RGBA</u></big></dt>
<dd>Alias for GL_RGBA <br><br>

</dd>
<dt><big><a name="Texture.Format.BGR"></a><u>BGR</u></big></dt>
<dd>Alias for GL_BGR <br><br>

</dd>
<dt><big><a name="Texture.Format.BGRA"></a><u>BGRA</u></big></dt>
<dd>Alias for GL_BGRA <br><br>

</dd>
<dt><big><a name="Texture.Format.Alpha"></a><u>Alpha</u></big></dt>
<dd>Alias for GL_ALPHA <br><br>

</dd>
<dt><big><a name="Texture.Format.Luminance"></a><u>Luminance</u></big></dt>
<dd>Alias for GL_LUMINANCE <br><br>

</dd>
<dt><big><a name="Texture.Format.LuminanceAlpha"></a><u>LuminanceAlpha</u></big></dt>
<dd>Alias for GL_LUMINANCE_ALPHA <br><br>

</dd>
<dt><big><a name="Texture.Format.CompressedRGB"></a><u>CompressedRGB</u></big></dt>
<dd>Compressed RGB<br><br>

</dd>
<dt><big><a name="Texture.Format.CompressedRGBA"></a><u>CompressedRGBA</u></big></dt>
<dd>Compressed RGBA<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture.Compression"></a>enum <u>Compression</u>;
</big></dt>
<dd><u>Compression</u> modes<br><br>

<dl><dt><big><a name="Texture.Compression.None"></a><u>None</u></big></dt>
<dd>No compression<br><br>

</dd>
<dt><big><a name="Texture.Compression.DontCare"></a><u>DontCare</u></big></dt>
<dd>The OpenGL implementation decide on their own<br><br>

</dd>
<dt><big><a name="Texture.Compression.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> compression<br><br>

</dd>
<dt><big><a name="Texture.Compression.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but slowest mode of compression<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture.this"></a>final  this();
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.this"></a>final  this(const Texture <i>tex</i>, Format <i>t_fmt</i> = Format.None);
</big></dt>
<dd>Postblit<br><br>

</dd>
<dt><big><a name="Texture.free"></a>final void <u>free</u>();
</big></dt>
<dd>Free / Delete the Texture &amp; Memory
 After this call, the Pixel data is invalid.<br><br>

</dd>
<dt><big><a name="Texture.currentlyBound"></a>static GLint <u>currentlyBound</u>();
</big></dt>
<dd>Returns the currently bound texture id.<br><br>

</dd>
<dt><big><a name="Texture.Id"></a>final const pure nothrow @property GLuint <u>Id</u>();
</big></dt>
<dd>Returns the Texture <u>Id</u>.<br><br>

</dd>
<dt><big><a name="Texture.isValid"></a>final const pure nothrow bool <u>isValid</u>();
</big></dt>
<dd>Returns if the texture is used.<br><br>

</dd>
<dt><big><a name="Texture.width"></a>final const pure nothrow @property ushort <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u> of this Texture<br><br>

</dd>
<dt><big><a name="Texture.height"></a>final const pure nothrow @property ushort <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u> of this Texture.<br><br>

</dd>
<dt><big><a name="Texture.depth"></a>final const pure nothrow @property ubyte <u>depth</u>();
</big></dt>
<dd>Returns the <u>depth</u>. May often 24 or 32.<br><br>

</dd>
<dt><big><a name="Texture.getFormat"></a>final const pure nothrow Format <u>getFormat</u>();
</big></dt>
<dd>Returns the Format.
<br><br>
<b>See:</b><br>
Format enum.<br><br>

</dd>
<dt><big><a name="Texture.bind"></a>final const void <u>bind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now activated.<br><br>

</dd>
<dt><big><a name="Texture.unbind"></a>final const void <u>unbind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now deactivated.<br><br>

</dd>
<dt><big><a name="Texture.isCurrentlyBound"></a>final const bool <u>isCurrentlyBound</u>();
</big></dt>
<dd>Returns <b>true</b>, if this Texture is currently activated.<br><br>

</dd>
<dt><big><a name="Texture.setSmooth"></a>final void <u>setSmooth</u>(bool <i>enable</i>);
</big></dt>
<dd>Set smooth filter for the (next) load.<br><br>

</dd>
<dt><big><a name="Texture.isSmooth"></a>final const pure nothrow bool <u>isSmooth</u>();
</big></dt>
<dd>Returns if smooth filter are activated.<br><br>

</dd>
<dt><big><a name="Texture.setRepeat"></a>final void <u>setRepeat</u>(bool <i>repeat</i>);
</big></dt>
<dd>Set repeating for the (next) load.<br><br>

</dd>
<dt><big><a name="Texture.isRepeated"></a>final const pure nothrow bool <u>isRepeated</u>();
</big></dt>
<dd>Returns if repeating is enabled.<br><br>

</dd>
<dt><big><a name="Texture.setCompression"></a>final void <u>setCompression</u>(Compression <i>comp</i>);
</big></dt>
<dd>(Re)Set the compression mode.
<br><br>
<b>See:</b><br>
Compression enum<br><br>

</dd>
<dt><big><a name="Texture.getCompression"></a>final const pure nothrow Compression <u>getCompression</u>();
</big></dt>
<dd>Returns the current Compression mode.
<br><br>
<b>See:</b><br>
Compression enum<br><br>

</dd>
<dt><big><a name="Texture.isCompressed"></a>final const bool <u>isCompressed</u>();
</big></dt>
<dd>Checks whether the current Texture is compressed or not.<br><br>

</dd>
<dt><big><a name="Texture.loadFromMemory"></a>final void <u>loadFromMemory</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>final void <u>setColorkey</u>(ref const Color <i>colorkey</i>);
</big></dt>
<dd>Set a <i>colorkey</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>final void <u>setColorkey</u>(const Color <i>colorkey</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.getMemory"></a>final const void* <u>getMemory</u>();
</big></dt>
<dd>Returns the pixel of this Texture or <b>null</b> if this Texture isn't valid.
<br><br>
<b>Note:</b><br>
This method <b>allocates</b> GC memory.<br><br>

</dd>
<dt><big><a name="Texture.subTexture"></a>final Texture <u>subTexture</u>(ref const ShortRect <i>rect</i>);
</big></dt>
<dd>Returns a <u>subTexture</u> of this Texture.
 This isn't similar to partial.<br><br>

</dd>
<dt><big><a name="Texture.subTexture"></a>final Texture <u>subTexture</u>(const ShortRect <i>rect</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.copy"></a>final void <u>copy</u>(const Texture <i>tex</i>, const ShortRect* <i>rect</i> = null);
</big></dt>
<dd>Copy another Texture to this.
 The second parameter is a pointer to the destination <i>rect</i>.
 Is it is <b>null</b> this means the whole <i>tex</i> is copied.<br><br>

</dd>
<dt><big><a name="Texture.updateMemory"></a>final void <u>updateMemory</u>(const void* <i>memory</i>, const ShortRect* <i>rect</i> = null, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Update the pixel data of this Texture.
 The second parameter is a pointer to the area which is updated.
 If it is <b>null</b> (default) the whole Texture will be updated.
 The third parameter is the format of the pixels.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
