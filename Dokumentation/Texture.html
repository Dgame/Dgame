<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Texture</title>
        </head><body>
        <h1>Dgame.Graphics.Texture</h1>
        <!-- Generated by Ddoc from C:\Users\Besitzer\Documents\GitHub\Dgame\Graphics\Texture.d -->
<br><br>
<dl><dt><big><a name="formatToBits"></a>pure ubyte <u>formatToBits</u>(Texture.Format <i>fmt</i>);
</big></dt>
<dd>Format a Texture.Format into the related bit count.
 If the format is not supported, it returns 0.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGBA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGB) == 24);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGRA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGR) == 24);
</pre>
<br><br>

</dd>
<dt><big><a name="bitsToFormat"></a>pure Texture.Format <u>bitsToFormat</u>(ubyte <i>bits</i>, bool <i>reverse</i> = false);
</big></dt>
<dd>Format a bit count into the related Texture.Format.
 If no bit count is supported, it returns Texture.Format.None.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>bitsToFormat</u>(32) == Texture.Format.RGBA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24) == Texture.Format.RGB);
<font color=blue>assert</font>(<u>bitsToFormat</u>(32, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24, <font color=blue>true</font>) == Texture.Format.BGR);
</pre>
<br><br>

</dd>
<dt><big><a name="switchFormat"></a>pure Texture.Format <u>switchFormat</u>(Texture.Format <i>fmt</i>, bool <i>alpha</i> = false);
</big></dt>
<dd>Switch/Reverse Texture.Format.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB) == Texture.Format.BGR);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA, <font color=blue>true</font>) == Texture.Format.BGRA);
</pre>
<br><br>

</dd>
<dt><big><a name="Texture"></a>class <u>Texture</u>: Dgame.Graphics.Interface.Blendable.Blendable;
</big></dt>
<dd>A <u>Texture</u> is a 2 dimensional pixel reprasentation.
 It is a wrapper of an OpenGL <u>Texture</u>.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Texture.Format"></a>enum <u>Format</u>;
</big></dt>
<dd>Supported Texture <u>Format</u><br><br>

<dl><dt><big><a name="Texture.Format.None"></a><u>None</u></big></dt>
<dd>Take this if you want to declare that you give no Format. <br><br>

</dd>
<dt><big><a name="Texture.Format.RGB"></a><u>RGB</u></big></dt>
<dd>Alias for GL_RGB <br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA"></a><u>RGBA</u></big></dt>
<dd>Alias for GL_RGBA <br><br>

</dd>
<dt><big><a name="Texture.Format.BGR"></a><u>BGR</u></big></dt>
<dd>Alias for GL_BGR <br><br>

</dd>
<dt><big><a name="Texture.Format.BGRA"></a><u>BGRA</u></big></dt>
<dd>Alias for GL_BGRA <br><br>

</dd>
<dt><big><a name="Texture.Format.Alpha"></a><u>Alpha</u></big></dt>
<dd>Alias for GL_ALPHA <br><br>

</dd>
<dt><big><a name="Texture.Format.Luminance"></a><u>Luminance</u></big></dt>
<dd>Alias for GL_LUMINANCE <br><br>

</dd>
<dt><big><a name="Texture.Format.LuminanceAlpha"></a><u>LuminanceAlpha</u></big></dt>
<dd>Alias for GL_LUMINANCE_ALPHA <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture._render"></a>package const void <u>_render</u>(const ShortRect <i>dst</i>, RenderMode <i>mode</i> = RenderMode.Normal);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.this"></a>final  this();
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.this"></a>final  this(ref const Texture <i>tex</i>, Format <i>t_fmt</i> = Format.None);
</big></dt>
<dd>Postblit<br><br>

</dd>
<dt><big><a name="Texture.free"></a>final void <u>free</u>();
</big></dt>
<dd>Free / Delete the Texture &amp; Memory
 After this call, the Pixel data is invalid.<br><br>

</dd>
<dt><big><a name="Texture.currentlyBound"></a>static GLint <u>currentlyBound</u>();
</big></dt>
<dd>Returns the currently bound texture id.<br><br>

</dd>
<dt><big><a name="Texture.getId"></a>final const pure nothrow GLuint <u>getId</u>();
</big></dt>
<dd>Returns the Texture Id.<br><br>

</dd>
<dt><big><a name="Texture.width"></a>final const pure nothrow @property ushort <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u> of this Texture<br><br>

</dd>
<dt><big><a name="Texture.height"></a>final const pure nothrow @property ushort <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u> of this Texture.<br><br>

</dd>
<dt><big><a name="Texture.depth"></a>final const pure nothrow @property ubyte <u>depth</u>();
</big></dt>
<dd>Returns the <u>depth</u>. May often 24 or 32.<br><br>

</dd>
<dt><big><a name="Texture.getFormat"></a>final const pure nothrow Format <u>getFormat</u>();
</big></dt>
<dd>Returns the Format.
<br><br>
<b>See:</b><br>
Format enum.<br><br>

</dd>
<dt><big><a name="Texture.bind"></a>final const void <u>bind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now activated.<br><br>

</dd>
<dt><big><a name="Texture.unbind"></a>final const void <u>unbind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now deactivated.<br><br>

</dd>
<dt><big><a name="Texture.isCurrentlyBound"></a>final const bool <u>isCurrentlyBound</u>();
</big></dt>
<dd>Returns <b>true</b>, if this Texture is currently activated.<br><br>

</dd>
<dt><big><a name="Texture.setSmooth"></a>final void <u>setSmooth</u>(bool <i>enable</i>);
</big></dt>
<dd>Set smooth filter for the (next) load.<br><br>

</dd>
<dt><big><a name="Texture.hasSmooth"></a>final const pure nothrow bool <u>hasSmooth</u>();
</big></dt>
<dd>Returns if smooth filter are activated.<br><br>

</dd>
<dt><big><a name="Texture.setRepeat"></a>final void <u>setRepeat</u>(bool <i>enable</i>);
</big></dt>
<dd>Set repeating for the (nexT) load.<br><br>

</dd>
<dt><big><a name="Texture.hasRepeat"></a>final const pure nothrow bool <u>hasRepeat</u>();
</big></dt>
<dd>Returns if repeating is enabled.<br><br>

</dd>
<dt><big><a name="Texture.hasViewport"></a>final const bool <u>hasViewport</u>();
</big></dt>
<dd>Check if this Texture has a Viewport.<br><br>

</dd>
<dt><big><a name="Texture.setViewport"></a>final void <u>setViewport</u>(ref const FloatRect <i>viewport</i>);
</big></dt>
<dd>Set a Viewport to this Texture.
 A Viewport is a ClipRect that is shorter as the whole Texture.
 If this Texture is drawn only the specific Viewport will be drawn.<br><br>

</dd>
<dt><big><a name="Texture.setViewport"></a>final void <u>setViewport</u>(const FloatRect <i>viewport</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.unsetViewport"></a>final void <u>unsetViewport</u>();
</big></dt>
<dd>Remove/Collapse the current Viewport.<br><br>

</dd>
<dt><big><a name="Texture.getViewport"></a>final const pure nothrow ref const(FloatRect) <u>getViewport</u>();
</big></dt>
<dd>Returns the current Viewport.<br><br>

</dd>
<dt><big><a name="Texture.fetchViewport"></a>final inout inout(FloatRect)* <u>fetchViewport</u>();
</big></dt>
<dd>Get mutable access to the current Viewport.<br><br>

</dd>
<dt><big><a name="Texture.link"></a>final void <u>link</u>(const Texture <i>tex</i>);
</big></dt>
<dd>Link this Texture to another.
 This Texture points now to the other Texture and his data.<br><br>

</dd>
<dt><big><a name="Texture.partial"></a>final const Texture <u>partial</u>(ref const FloatRect <i>viewport</i>, bool <i>copy</i> = false);
</big></dt>
<dd>Returns a new Texture object which rested <u>partial</u> of these Texture.
 If you pass as second parameter <b>true</b>, the whole Texture will be copied
 with the postblit CTor and then a <i>viewport</i> is set.
 If you pass <b>false</b> (default), nothing is copied, but the new Object points (link)
 to these. Then a <i>viewport</i> is set also.
<br><br>
<b>See:</b><br>
postblit CTor
<br><br>
<b>See:</b><br>
link<br><br>

</dd>
<dt><big><a name="Texture.partial"></a>final const Texture <u>partial</u>(const FloatRect <i>viewport</i>, bool <i>copy</i> = false);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.loadFromMemory"></a>final void <u>loadFromMemory</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>final void <u>setColorkey</u>(ref const Color <i>colorkey</i>);
</big></dt>
<dd>Load from memory with a <i>colorkey</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>final void <u>setColorkey</u>(const Color <i>colorkey</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.getMemory"></a>final const void* <u>getMemory</u>();
</big></dt>
<dd>Returns the pixel of this Texture or <b>null</b> if this Texture isn't valid.
<br><br>
<b>Note:</b><br>
This method <b>allocates</b> memory.<br><br>

</dd>
<dt><big><a name="Texture.subTexture"></a>final Texture <u>subTexture</u>(ref const ShortRect <i>rect</i>);
</big></dt>
<dd>Returns a <u>subTexture</u> of this Texture.
 This isn't similar to partial.<br><br>

</dd>
<dt><big><a name="Texture.subTexture"></a>final Texture <u>subTexture</u>(const ShortRect <i>rect</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Texture.copy"></a>final void <u>copy</u>(const Texture <i>tex</i>, ShortRect* <i>rect</i> = null);
</big></dt>
<dd>Copy another Texture to this.
 The second parameter is a pointer to the destination <i>rect</i>.
 Is it is <b>null</b> this means the whole <i>tex</i> is copied.<br><br>

</dd>
<dt><big><a name="Texture.updateMemory"></a>final void <u>updateMemory</u>(const void* <i>memory</i>, ShortRect* <i>rect</i> = null, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Update the pixel data of this Texture.
 The second parameter is a pointer to the area which is updated.
 If it is <b>null</b> (default) the whole Texture will be updated.
 The third parameter is the format of the pixels.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
