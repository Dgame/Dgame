<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Surface</title>
        </head><body>
        <h1>Dgame.Graphics.Surface</h1>
        <!-- Generated by Ddoc from C:\Users\Besitzer\Documents\GitHub\Dgame\Graphics\Surface.d -->
<br><br>
<dl><dt><big><a name="Surface"></a>struct <u>Surface</u>;
</big></dt>
<dd>version = Develop;
<br><br>
<u>Surface</u> is a wrapper for a SDL_Surface.

<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Surface.BlendMode"></a>enum <u>BlendMode</u>;
</big></dt>
<dd>Supported BlendModes<br><br>

<dl><dt><big><a name="Surface.BlendMode.None"></a><u>None</u></big></dt>
<dd>no blending <br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Blend"></a><u>Blend</u></big></dt>
<dd>dst = (src * A) + (dst * (1-A)) <br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Add"></a><u>Add</u></big></dt>
<dd>dst = (src * A) + dst <br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Mod"></a><u>Mod</u></big></dt>
<dd>dst = src * dst <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Surface.Mask"></a>enum <u>Mask</u>;
</big></dt>
<dd>Supported Color Masks<br><br>

<dl><dt><big><a name="Surface.Mask.Red"></a><u>Red</u></big></dt>
<dd><u>Red</u> Mask <br><br>

</dd>
<dt><big><a name="Surface.Mask.Green"></a><u>Green</u></big></dt>
<dd><u>Green</u> Mask <br><br>

</dd>
<dt><big><a name="Surface.Mask.Blue"></a><u>Blue</u></big></dt>
<dd><u>Blue</u> Mask <br><br>

</dd>
<dt><big><a name="Surface.Mask.Alpha"></a><u>Alpha</u></big></dt>
<dd><u>Alpha</u> Mask <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Surface.RMask"></a><u>RMask</u></big></dt>
<dd>Default Red Mask. <br><br>

</dd>
<dt><big><a name="Surface.GMask"></a><u>GMask</u></big></dt>
<dd>Default Green Mask. <br><br>

</dd>
<dt><big><a name="Surface.BMask"></a><u>BMask</u></big></dt>
<dd>Default Blue Mask. <br><br>

</dd>
<dt><big><a name="Surface.AMask"></a>uint <u>AMask</u>;
</big></dt>
<dd>wenn auf all -&gt; blit funktioniert nicht<br><br>

</dd>
<dt><big><a name="Surface.Flip"></a>enum <u>Flip</u>;
</big></dt>
<dd><u>Flip</u> mode<br><br>

<dl><dt><big><a name="Surface.Flip.Vertical"></a><u>Vertical</u></big></dt>
<dd><u>Vertical</u> Flip <br><br>

</dd>
<dt><big><a name="Surface.Flip.Horizontal"></a><u>Horizontal</u></big></dt>
<dd><u>Horizontal</u> Flip <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Surface.this"></a> this(string <i>filename</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Surface.this"></a> this(SDL_Surface* <i>srfc</i>, bool <i>link</i>);
</big></dt>
<dd>CTor
 If <i>link</i> is <b>true</b>, <i>srfc</i> is linked to this.
 Otherwise a copy is created.<br><br>

</dd>
<dt><big><a name="Surface.opAssign"></a>void <u>opAssign</u>(ref Surface <i>rhs</i>);
</big></dt>
<dd><u>opAssign</u><br><br>

</dd>
<dt><big><a name="Surface.opAssign"></a>void <u>opAssign</u>(Surface <i>rhs</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.free"></a>void <u>free</u>();
</big></dt>
<dd>Destroy the current Surface <b>and all, which are linked to this Surface</b>.
 This method is called from the DTor.<br><br>

</dd>
<dt><big><a name="Surface.useCount"></a>const pure nothrow uint <u>useCount</u>();
</big></dt>
<dd>Returns the current use count<br><br>

</dd>
<dt><big><a name="Surface.make"></a>static Surface <u>make</u>(ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32);
</big></dt>
<dd>Make a new Surface of the given <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.create"></a>static SDL_Surface* <u>create</u>(ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32);
</big></dt>
<dd>Create a new SDL_Surface* of the given <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.make"></a>static Surface <u>make</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32);
</big></dt>
<dd>Make an new Surface of the given <i>memory</i>, <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.create"></a>static SDL_Surface* <u>create</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32);
</big></dt>
<dd>Create a new SDL_Surface* of the given <i>memory</i>, <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.isValid"></a>const pure nothrow bool <u>isValid</u>();
</big></dt>
<dd>Returns if the Surface is valid. Which means that the Surface has valid data.<br><br>

</dd>
<dt><big><a name="Surface.filename"></a>const pure nothrow @property string <u>filename</u>();
</big></dt>
<dd>Returns the <u>filename</u>, if any<br><br>

</dd>
<dt><big><a name="Surface.loadFromFile"></a>void <u>loadFromFile</u>(string <i>filename</i>);
</big></dt>
<dd>Load from <i>filename</i>. If any data is already stored, the data will be freed.<br><br>

</dd>
<dt><big><a name="Surface.loadFromMemory"></a>void <u>loadFromMemory</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Surface.saveToFile"></a>void <u>saveToFile</u>(string <i>filename</i>);
</big></dt>
<dd>Save the current pixel data to the file.<br><br>

</dd>
<dt><big><a name="Surface.width"></a>const pure nothrow @property ushort <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u>.<br><br>

</dd>
<dt><big><a name="Surface.height"></a>const pure nothrow @property ushort <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u>.<br><br>

</dd>
<dt><big><a name="Surface.fill"></a>void <u>fill</u>(ref const Color <i>col</i>, const ShortRect* <i>rect</i> = null);
</big></dt>
<dd>Fills a specific area of the surface with the given color.
 The second parameter is a pointer to the area.
 If it's <b>null</b>, the whole Surface is filled.<br><br>

</dd>
<dt><big><a name="Surface.fill"></a>void <u>fill</u>(const Color <i>col</i>, const ShortRect* <i>rect</i> = null);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.fillAreas"></a>void <u>fillAreas</u>(ref const Color <i>col</i>, const ShortRect[] <i>rects</i>);
</big></dt>
<dd>Fills multiple areas of the Surface with the given color.<br><br>

</dd>
<dt><big><a name="Surface.fillAreas"></a>void <u>fillAreas</u>(const Color <i>col</i>, const ShortRect[] <i>rects</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.optimizeRLE"></a>bool <u>optimizeRLE</u>(bool <i>enable</i>);
</big></dt>
<dd>Use this function to set the RLE acceleration hint for a surface.
 RLE (Run-Length-Encoding) is a way of compressing data.
 If RLE is enabled, color key and alpha blending blits are much faster,
 but the surface must be locked before directly accessing the pixels.
<br><br>
<b>Returns:</b><br>
whether the call succeeded or not<br><br>

</dd>
<dt><big><a name="Surface.lock"></a>bool <u>lock</u>();
</big></dt>
<dd>Use this function to set up a surface for directly accessing the pixels.
<br><br>
<b>Returns:</b><br>
whether the call succeeded or not<br><br>

</dd>
<dt><big><a name="Surface.unlock"></a>void <u>unlock</u>();
</big></dt>
<dd>Use this function to release a surface after directly accessing the pixels.<br><br>

</dd>
<dt><big><a name="Surface.isLocked"></a>const pure nothrow bool <u>isLocked</u>();
</big></dt>
<dd>Returns whether this Surface is locked or not.<br><br>

</dd>
<dt><big><a name="Surface.mustLock"></a>bool <u>mustLock</u>();
</big></dt>
<dd>Use this function to determine whether a surface must be locked for access.<br><br>

</dd>
<dt><big><a name="Surface.adaptTo"></a>void <u>adaptTo</u>(ref Surface <i>srfc</i>);
</big></dt>
<dd>Use this function to adapt the format of another Surface to this surface.
 Works like <code>SDL_DisplayFormat</code>.<br><br>

</dd>
<dt><big><a name="Surface.adaptTo"></a>void <u>adaptTo</u>(SDL_PixelFormat* <i>fmt</i>);
</big></dt>
<dd>Use this function to adapt the format of another Surface to this surface.
 Works like <code>SLD_DisplayFormat</code>.<br><br>

</dd>
<dt><big><a name="Surface.setColorkey"></a>void <u>setColorkey</u>(ref const Color <i>col</i>);
</big></dt>
<dd>Set the colorkey.<br><br>

</dd>
<dt><big><a name="Surface.setColorkey"></a>void <u>setColorkey</u>(const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.setColorkey"></a>void <u>setColorkey</u>(ubyte <i>red</i>, ubyte <i>green</i>, ubyte <i>blue</i>, short <i>alpha</i> = -1);
</big></dt>
<dd>Set the colorkey.<br><br>

</dd>
<dt><big><a name="Surface.getColorkey"></a>Color <u>getColorkey</u>();
</big></dt>
<dd>Returns the current colorkey.<br><br>

</dd>
<dt><big><a name="Surface.setAlphaMod"></a>void <u>setAlphaMod</u>(ubyte <i>alpha</i>);
</big></dt>
<dd>Set the Alpha mod.<br><br>

</dd>
<dt><big><a name="Surface.getAlphaMod"></a>ubyte <u>getAlphaMod</u>();
</big></dt>
<dd>Returns the current Alpha mod.<br><br>

</dd>
<dt><big><a name="Surface.setBlendMode"></a>void <u>setBlendMode</u>(BlendMode <i>mode</i>);
</big></dt>
<dd>Set the Blendmode.<br><br>

</dd>
<dt><big><a name="Surface.getBlendMode"></a>BlendMode <u>getBlendMode</u>();
</big></dt>
<dd>Returns the current Blendmode.<br><br>

</dd>
<dt><big><a name="Surface.getClipRect"></a>ShortRect <u>getClipRect</u>();
</big></dt>
<dd>Returns the clip rect of this surface.
 The clip rect is the area of the surface which is drawn.<br><br>

</dd>
<dt><big><a name="Surface.setClipRect"></a>void <u>setClipRect</u>(ref const ShortRect <i>clip</i>);
</big></dt>
<dd>Set the <i>clip</i> rect.<br><br>

</dd>
<dt><big><a name="Surface.setClipRect"></a>void <u>setClipRect</u>(const ShortRect <i>clip</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.getPixels"></a>inout inout(void*) <u>getPixels</u>();
</big></dt>
<dd>Returns the pixel data of this surface.<br><br>

</dd>
<dt><big><a name="Surface.countBits"></a>const pure nothrow ubyte <u>countBits</u>();
</big></dt>
<dd>Count the bits of this surface.
 Could be 32, 24, 16, 8, 0.<br><br>

</dd>
<dt><big><a name="Surface.countBytes"></a>const pure nothrow ubyte <u>countBytes</u>();
</big></dt>
<dd>Count the bytes of this surface.
 Could be 4, 3, 2, 1, 0. (countBits / 8)<br><br>

</dd>
<dt><big><a name="Surface.getPitch"></a>const pure nothrow int <u>getPitch</u>();
</big></dt>
<dd>Returns the Surface pitch or 0.<br><br>

</dd>
<dt><big><a name="Surface.getPixelFormat"></a>const pure nothrow const(SDL_PixelFormat*) <u>getPixelFormat</u>();
</big></dt>
<dd>Returns the PixelFormat<br><br>

</dd>
<dt><big><a name="Surface.isMask"></a>const bool <u>isMask</u>(Mask <i>mask</i>, ref const Color <i>col</i>);
</big></dt>
<dd>Returns if the given color match the color of the given <i>mask</i> of the surface.
<br><br>
<b>See:</b><br>
Surface.Mask enum.<br><br>

</dd>
<dt><big><a name="Surface.isMask"></a>const bool <u>isMask</u>(Mask <i>mask</i>, const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.isMask"></a>const bool <u>isMask</u>(Mask <i>mask</i>, uint <i>col</i>);
</big></dt>
<dd>Returns if the given converted color match the color of the given <i>mask</i> of the surface.
<br><br>
<b>See:</b><br>
Surface.Mask enum.<br><br>

</dd>
<dt><big><a name="Surface.getPixelAt"></a>const ubyte* <u>getPixelAt</u>(ref const Vector2s <i>pos</i>);
</big></dt>
<dd>Returns a pointer of the pixel at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.getPixelAt"></a>const ubyte* <u>getPixelAt</u>(ushort <i>x</i>, ushort <i>y</i>);
</big></dt>
<dd>Returns a pointer of the pixel at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.putPixelAt"></a>void <u>putPixelAt</u>(ref const Vector2s <i>pos</i>, ubyte <i>pixel</i>);
</big></dt>
<dd>Put a new <i>pixel</i> at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.putPixelAt"></a>void <u>putPixelAt</u>(ushort <i>x</i>, ushort <i>y</i>, ubyte <i>pixel</i>);
</big></dt>
<dd>Put a new <i>pixel</i> at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.getColorAt"></a>const Color <u>getColorAt</u>(ref const Vector2s <i>pos</i>);
</big></dt>
<dd>Returns the color on the given position.<br><br>

</dd>
<dt><big><a name="Surface.getColorAt"></a>const Color <u>getColorAt</u>(ushort <i>x</i>, ushort <i>y</i>);
</big></dt>
<dd>Returns the color on the given position.<br><br>

</dd>
<dt><big><a name="Surface.ptr"></a>inout pure nothrow @property inout(SDL_Surface)* <u>ptr</u>();
</big></dt>
<dd>Returns a pointer of the SDL_Surface<br><br>

</dd>
<dt><big><a name="Surface.softStretch"></a>bool <u>softStretch</u>(ref Surface <i>srfc</i>, const ShortRect* <i>src</i> = null, const ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform a fast, low quality,
 stretch blit between two surfaces of the same pixel format.
 <i>src</i> is the a pointer to a Rect structure which represents the rectangle to be copied,
 or <b>null</b> to copy the entire surface.
 <i>dst</i> is a pointer to a Rect structure which represents the rectangle that is copied into.
 <b>null</b> means, that the whole <i>srfc</i> is copied to (0|0).<br><br>

</dd>
<dt><big><a name="Surface.softStretch"></a>bool <u>softStretch</u>(SDL_Surface* <i>srfc</i>, const ShortRect* <i>src</i> = null, const ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Same as above, but with a SDL_Surface* instead of a Surface.<br><br>

</dd>
<dt><big><a name="Surface.upperBlit"></a>bool <u>upperBlit</u>(ref Surface <i>srfc</i>, const ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform a fast blit from the source surface to the this surface<br><br>

</dd>
<dt><big><a name="Surface.upperBlit"></a>bool <u>upperBlit</u>(SDL_Surface* <i>srfc</i>, const ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Same as above, but with a SDL_Surface* instead of a Surface.<br><br>

</dd>
<dt><big><a name="Surface.lowerBlit"></a>bool <u>lowerBlit</u>(ref Surface <i>srfc</i>, ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform low-level surface blitting only.<br><br>

</dd>
<dt><big><a name="Surface.lowerBlit"></a>bool <u>lowerBlit</u>(SDL_Surface* <i>srfc</i>, ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Same as above, but with a SDL_Surface* instead of a Surface.<br><br>

</dd>
<dt><big><a name="Surface.blit"></a>bool <u>blit</u>(ref Surface <i>srfc</i>, const ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform a fast <u>blit</u> from the source surface to the this surface.
 <i>src</i> is the a pointer to a Rect structure which represents the rectangle to be copied,
 or <b>null</b> to copy the entire surface.
 <i>dst</i> is a pointer to a Rect structure which represents the rectangle that is copied into.
 <b>null</b> means, that the whole <i>srfc</i> is copied to (0|0).<br><br>

</dd>
<dt><big><a name="Surface.blit"></a>bool <u>blit</u>(SDL_Surface* <i>srfc</i>, const ShortRect* <i>src</i> = null, ShortRect* <i>dst</i> = null);
</big></dt>
<dd>Same as above, but with a SDL_Surface* instead of a Surface.<br><br>

</dd>
<dt><big><a name="Surface.subSurface"></a>Surface <u>subSurface</u>(ref const ShortRect <i>rect</i>);
</big></dt>
<dd>Returns a subsurface from this surface. <i>rect</i> represents the viewport.
 The subsurface is a separate Surface object.<br><br>

</dd>
<dt><big><a name="Surface.subSurface"></a>Surface <u>subSurface</u>(const ShortRect <i>rect</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Surface.flip"></a>Surface <u>flip</u>(Flip <u>flip</u>);
</big></dt>
<dd>Returns an new flipped Surface
 The current Surface is not modified.
<br><br>
<b>Note:</b><br>
This function is slow<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
