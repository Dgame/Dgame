<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Shape</title>
        </head><body>
        <h1>Dgame.Graphics.Shape</h1>
        <!-- Generated by Ddoc from C:\Users\Besitzer\Documents\GitHub\Dgame\Graphics\Shape.d -->
<br><br>
<dl><dt><big><a name="Smooth"></a>struct <u>Smooth</u>;
</big></dt>
<dd><u>Smooth</u> wrapper<br><br>

<dl><dt><big><a name="Smooth.Target"></a>enum <u>Target</u>;
</big></dt>
<dd>Supported smooth targets.<br><br>

<dl><dt><big><a name="Smooth.Target.None"></a><u>None</u></big></dt>
<dd>No smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Target.Point"></a><u>Point</u></big></dt>
<dd>Enable smooth for points. <br><br>

</dd>
<dt><big><a name="Smooth.Target.Line"></a><u>Line</u></big></dt>
<dd>Enable smooth for lines. <br><br>

</dd>
<dt><big><a name="Smooth.Target.Polygon"></a><u>Polygon</u></big></dt>
<dd>Enable smooth for polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.Hint"></a>enum <u>Hint</u>;
</big></dt>
<dd>Smooth Hints to determine
 which kind of smoothing is made.<br><br>

<dl><dt><big><a name="Smooth.Hint.DontCare"></a><u>DontCare</u></big></dt>
<dd>The OpenGL implementation decide on their own. <br><br>

</dd>
<dt><big><a name="Smooth.Hint.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> kind of smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Hint.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but lowest kind of smooth. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.getTarget"></a>const pure nothrow Target <u>getTarget</u>();
</big></dt>
<dd>Returns the current target<br><br>

</dd>
<dt><big><a name="Smooth.getHint"></a>const pure nothrow Hint <u>getHint</u>();
</big></dt>
<dd>Return the current hint<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="primitiveToShape"></a>pure nothrow @safe Shape.Type <u>primitiveToShape</u>(Primitive.Type <i>ptype</i>);
</big></dt>
<dd>Converts a PrimitiveType of the StaticBuffer into a valid Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum
<br><br>
<b>See:</b><br>
PrimitiveType enum in StaticBuffer<br><br>

</dd>
<dt><big><a name="shapeToPrimitive"></a>pure nothrow @safe Primitive.Type <u>shapeToPrimitive</u>(Shape.Type <i>stype</i>);
</big></dt>
<dd>Converts a Shape Type into a valid PrimitiveType of the StaticBuffer
<br><br>
<b>See:</b><br>
Shape.Type enum
<br><br>
<b>See:</b><br>
PrimitiveType enum in StaticBuffer<br><br>

</dd>
<dt><big><a name="Shape"></a>class <u>Shape</u>: Dgame.Graphics.Transformable.Transformable, Dgame.Graphics.Drawable.Drawable;
</big></dt>
<dd><u>Shape</u> defines a drawable convex shape.
 It also defines helper functions to draw simple shapes like lines, rectangles, circles, etc.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Shape.Type"></a>enum <u>Type</u>;
</big></dt>
<dd>Supported shape types.<br><br>

<dl><dt><big><a name="Shape.Type.Quad"></a><u>Quad</u></big></dt>
<dd>Declare that the stored vertices are Quads. <br><br>

</dd>
<dt><big><a name="Shape.Type.QuadStrip"></a><u>QuadStrip</u></big></dt>
<dd>Declare that the stored vertices are Quad Strips<br><br>

</dd>
<dt><big><a name="Shape.Type.Triangle"></a><u>Triangle</u></big></dt>
<dd>Declare that the stored vertices are Triangles. <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleStrip"></a><u>TriangleStrip</u></big></dt>
<dd>Declare that the stored vertices are Triangles Strips <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleFan"></a><u>TriangleFan</u></big></dt>
<dd>Declare that the stored vertices are Triangles Fans. <br><br>

</dd>
<dt><big><a name="Shape.Type.Lines"></a><u>Lines</u></big></dt>
<dd>Declare that the stored vertices are <u>Lines</u>. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineStrip"></a><u>LineStrip</u></big></dt>
<dd>Declare that the stored vertices are Line Strips. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineLoop"></a><u>LineLoop</u></big></dt>
<dd>Declare that the stored vertices are Line Loops. <br><br>

</dd>
<dt><big><a name="Shape.Type.Polygon"></a><u>Polygon</u></big></dt>
<dd>Declare that the stored vertices are Polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.this"></a>final  this(Type <i>type</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Shape.setSmooth"></a>final pure nothrow void <u>setSmooth</u>(Smooth.Target <i>sTarget</i>, Smooth.Hint <i>sHint</i> = Smooth.Hint.Fastest);
</big></dt>
<dd>Set target and hint of smoothing.<br><br>

</dd>
<dt><big><a name="Shape.getSmooth"></a>final const pure nothrow ref const(Smooth) <u>getSmooth</u>();
</big></dt>
<dd>Return the current smooth<br><br>

</dd>
<dt><big><a name="Shape.update"></a>final pure nothrow void <u>update</u>(bool <u>update</u> = true);
</big></dt>
<dd>The current shape will be updated.
 If 'autoUpdate' is activated, this happens automatically,
 otherwise you should use this.<br><br>

</dd>
<dt><big><a name="Shape.setType"></a>final pure nothrow void <u>setType</u>(Type <i>type</i>);
</big></dt>
<dd>Set or replace the current Shape <i>type</i>.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.getType"></a>final const pure nothrow Type <u>getType</u>();
</big></dt>
<dd>Returns the Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>final void <u>setPixelColor</u>(ref const Color <i>col</i>);
</big></dt>
<dd>Set for <b>all</b> vertices a (new) color.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>final void <u>setPixelColor</u>(const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.enableFill"></a>final pure nothrow void <u>enableFill</u>(bool <i>fill</i>);
</big></dt>
<dd>Activate <i>fill</i> mode.
 This means the whole shape is drawn and not only the outlines.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.shouldFill"></a>final const pure nothrow bool <u>shouldFill</u>();
</big></dt>
<dd>Returns if the fill mode is active or not.<br><br>

</dd>
<dt><big><a name="Shape.setLineWidth"></a>final pure nothrow void <u>setLineWidth</u>(ubyte <i>width</i>);
</big></dt>
<dd>Set the line <i>width</i>.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.getLineWidth"></a>final const pure nothrow ubyte <u>getLineWidth</u>();
</big></dt>
<dd>Returns the line width.<br><br>

</dd>
<dt><big><a name="Shape.appendVector"></a>final void <u>appendVector</u>(ref const Vector2f <i>vec</i>);
</big></dt>
<dd>Stores Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendVector"></a>final void <u>appendVector</u>(const Vector2f <i>vec</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.appendPixel"></a>final void <u>appendPixel</u>(ref const Pixel <i>vx</i>);
</big></dt>
<dd>Stores a Pixel for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendPixels"></a>final void <u>appendPixels</u>(const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Stores multiple Vertices for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendVectors"></a>final void <u>appendVectors</u>(const Vector2f[] <i>vec</i>);
</big></dt>
<dd>Stores multiple Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.remove"></a>final void <u>remove</u>(uint <i>index</i>, Pixel* <i>vp</i> = null);
</big></dt>
<dd>Remove the Pixel on the specific <i>index</i>.
 If <i>vp</i> is not <b>null</b>, the droped Pixel is stored there.<br><br>

</dd>
<dt><big><a name="Shape.getPixels"></a>final const pure nothrow const(Pixel[]) <u>getPixels</u>();
</big></dt>
<dd>Returns all Pixel of this Shape.<br><br>

</dd>
<dt><big><a name="Shape.getPixelAt"></a>final const ref const(Pixel) <u>getPixelAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns the Pixel at the given index
 or throws an exception, if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.fetchPixelAt"></a>final inout inout(Pixel)* <u>fetchPixelAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a pointer of the Pixel at the given index
 or <b>null</b> if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Vector2f[] <i>vec</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(ubyte <i>radius</i>, ref const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Make a new Shape object as Circle.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(ubyte <i>radius</i>, const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
