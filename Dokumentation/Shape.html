<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Shape</title>
        </head><body>
        <h1>Dgame.Graphics.Shape</h1>
        <!-- Generated by Ddoc from Graphics\Shape.d -->
<br><br>
<dl><dt><big><a name="Shape"></a>class <u>Shape</u>: Dgame.Graphics.Drawable.Drawable, Dgame.Graphics.Interface.Transformable.Transformable, Dgame.Graphics.Interface.Blendable.Blendable;
</big></dt>
<dd><u>Shape</u> defines a drawable convex shape.
 It also defines helper functions to draw simple shapes like lines, rectangles, circles, etc.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Shape.Type"></a>enum <u>Type</u>;
</big></dt>
<dd>Supported shape types.<br><br>

<dl><dt><big><a name="Shape.Type.Quad"></a><u>Quad</u></big></dt>
<dd>Declare that the stored vertices are Quads. <br><br>

</dd>
<dt><big><a name="Shape.Type.QuadStrip"></a><u>QuadStrip</u></big></dt>
<dd>Declare that the stored vertices are Quad Strips<br><br>

</dd>
<dt><big><a name="Shape.Type.Triangle"></a><u>Triangle</u></big></dt>
<dd>Declare that the stored vertices are Triangles. <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleStrip"></a><u>TriangleStrip</u></big></dt>
<dd>Declare that the stored vertices are Triangles Strips <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleFan"></a><u>TriangleFan</u></big></dt>
<dd>Declare that the stored vertices are Triangles Fans. <br><br>

</dd>
<dt><big><a name="Shape.Type.Lines"></a><u>Lines</u></big></dt>
<dd>Declare that the stored vertices are <u>Lines</u>. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineStrip"></a><u>LineStrip</u></big></dt>
<dd>Declare that the stored vertices are Line Strips. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineLoop"></a><u>LineLoop</u></big></dt>
<dd>Declare that the stored vertices are Line Loops. <br><br>

</dd>
<dt><big><a name="Shape.Type.Polygon"></a><u>Polygon</u></big></dt>
<dd>Declare that the stored vertices are Polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.SmoothTarget"></a>enum <u>SmoothTarget</u>;
</big></dt>
<dd>Supported smooth targets.<br><br>

<dl><dt><big><a name="Shape.SmoothTarget.None"></a><u>None</u></big></dt>
<dd>No smooth (default). <br><br>

</dd>
<dt><big><a name="Shape.SmoothTarget.Point"></a><u>Point</u></big></dt>
<dd>Enable smooth for points. <br><br>

</dd>
<dt><big><a name="Shape.SmoothTarget.Line"></a><u>Line</u></big></dt>
<dd>Enable smooth for lines. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.SmoothHint"></a>enum <u>SmoothHint</u>;
</big></dt>
<dd>Smooth Hints to determine
 which kind of smoothing is made.<br><br>

<dl><dt><big><a name="Shape.SmoothHint.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> kind of smooth (default). <br><br>

</dd>
<dt><big><a name="Shape.SmoothHint.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but lowest kind of smooth. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.this"></a> this(Type <i>type</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Shape.setSmooth"></a>void <u>setSmooth</u>(SmoothTarget <i>sTarget</i>, SmoothHint <i>sHint</i> = (SmoothHint).Fastest);
</big></dt>
<dd>Set target and hint of smoothing.<br><br>

</dd>
<dt><big><a name="Shape.getSmoothTarget"></a>const pure nothrow SmoothTarget <u>getSmoothTarget</u>();
</big></dt>
<dd>Return smooth target;<br><br>

</dd>
<dt><big><a name="Shape.getSmoothHint"></a>const pure nothrow SmoothHint <u>getSmoothHint</u>();
</big></dt>
<dd>Returns smooth hint.<br><br>

</dd>
<dt><big><a name="Shape.update"></a>void <u>update</u>(Cache <i>val</i>);
</big></dt>
<dd>Activate an <u>update</u>.
 The current shape will be updated.
 In most cases, this happens automatically,
 but sometimes it is usefull.<br><br>

</dd>
<dt><big><a name="Shape.setType"></a>void <u>setType</u>(Type <i>type</i>);
</big></dt>
<dd>Set or replace the current Shape <i>type</i>.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.getType"></a>const pure nothrow Type <u>getType</u>();
</big></dt>
<dd>Returns the Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>void <u>setPixelColor</u>(ref const Color <i>col</i>);
</big></dt>
<dd>Set for <b>all</b> vertices a (new) color.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>void <u>setPixelColor</u>(const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.enableFill"></a>void <u>enableFill</u>(bool <i>fill</i>);
</big></dt>
<dd>Activate <i>fill</i> mode.
 This means the whole shape is drawn and not only the outlines.<br><br>

</dd>
<dt><big><a name="Shape.shouldFill"></a>const pure nothrow bool <u>shouldFill</u>();
</big></dt>
<dd>Returns if the fill mode is active or not.<br><br>

</dd>
<dt><big><a name="Shape.setLineWidth"></a>void <u>setLineWidth</u>(ubyte <i>width</i>);
</big></dt>
<dd>Set the line <i>width</i>.<br><br>

</dd>
<dt><big><a name="Shape.getLineWidth"></a>const pure nothrow ubyte <u>getLineWidth</u>();
</big></dt>
<dd>Returns the line width.<br><br>

</dd>
<dt><big><a name="Shape.addVector"></a>void <u>addVector</u>(ref const Vector2f <i>vec</i>);
</big></dt>
<dd>Stores Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.addVector"></a>void <u>addVector</u>(const Vector2f <i>vec</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.addPixel"></a>void <u>addPixel</u>(ref const Pixel <i>vx</i>);
</big></dt>
<dd>Stores a Pixel for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.addPixels"></a>void <u>addPixels</u>(const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Stores multiple Vertices for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.addVectors"></a>void <u>addVectors</u>(const Vector2!(float)[] <i>vec</i>);
</big></dt>
<dd>Stores multiple Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.dropPixel"></a>void <u>dropPixel</u>(size_t <i>index</i>, Pixel* <i>vp</i> = null);
</big></dt>
<dd>Drop the Pixel on the specific <i>index</i>.
 If <i>vp</i> is not <b>null</b>, the droped Pixel is stored there.<br><br>

</dd>
<dt><big><a name="Shape.getPixels"></a>const pure nothrow ref const(Pixel[]) <u>getPixels</u>();
</big></dt>
<dd>Returns all Pixel of this Shape.<br><br>

</dd>
<dt><big><a name="Shape.getPixelAt"></a>inout ref inout(Pixel) <u>getPixelAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.getVectorAt"></a>inout ref inout(Vector2f) <u>getVectorAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel coordinates on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.getColorAt"></a>inout ref inout(Color) <u>getColorAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel color on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Vector2!(float)[] <i>vec</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(float <i>radius</i>, ref const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Make a new Shape object as Circle.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(float <i>radius</i>, const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
