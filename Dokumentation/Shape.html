<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Shape</title>
        </head><body>
        <h1>Dgame.Graphics.Shape</h1>
        <!-- Generated by Ddoc from Graphics\Shape.d -->
<br><br>
<dl><dt><big><a name="Smooth"></a>struct <u>Smooth</u>;
</big></dt>
<dd><u>Smooth</u> wrapper<br><br>

<dl><dt><big><a name="Smooth.Target"></a>enum <u>Target</u>: int;
</big></dt>
<dd>Supported smooth targets.<br><br>

<dl><dt><big><a name="Smooth.Target.None"></a><u>None</u></big></dt>
<dd>No smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Target.Point"></a><u>Point</u></big></dt>
<dd>Enable smooth for points. <br><br>

</dd>
<dt><big><a name="Smooth.Target.Line"></a><u>Line</u></big></dt>
<dd>Enable smooth for lines. <br><br>

</dd>
<dt><big><a name="Smooth.Target.Polygon"></a><u>Polygon</u></big></dt>
<dd>Enable smooth for polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.Mode"></a>enum <u>Mode</u>: uint;
</big></dt>
<dd>The smooth mode<br><br>

<dl><dt><big><a name="Smooth.Mode.DontCare"></a><u>DontCare</u></big></dt>
<dd>The OpenGL implementation decide on their own. <br><br>

</dd>
<dt><big><a name="Smooth.Mode.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> kind of smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Mode.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but slowest kind of smooth. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.getTarget"></a>const pure nothrow Target <u>getTarget</u>();
</big></dt>
<dd>Returns the current target<br><br>

</dd>
<dt><big><a name="Smooth.getMode"></a>const pure nothrow Mode <u>getMode</u>();
</big></dt>
<dd>Return the current mode<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="primitiveToShape"></a>pure nothrow @safe Shape.Type <u>primitiveToShape</u>(Primitive.Type <i>ptype</i>);
</big></dt>
<dd>Converts a PrimitiveType of the StaticBuffer into a valid Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum
<br><br>
<b>See:</b><br>
PrimitiveType enum in StaticBuffer<br><br>

</dd>
<dt><big><a name="shapeToPrimitive"></a>pure nothrow @safe Primitive.Type <u>shapeToPrimitive</u>(Shape.Type <i>stype</i>);
</big></dt>
<dd>Converts a Shape Type into a valid PrimitiveType of the StaticBuffer
<br><br>
<b>See:</b><br>
Shape.Type enum
<br><br>
<b>See:</b><br>
PrimitiveType enum in StaticBuffer<br><br>

</dd>
<dt><big><a name="Shape"></a>class <u>Shape</u>: Dgame.Graphics.Transformable.Transformable, Dgame.Graphics.Drawable.Drawable;
</big></dt>
<dd><u>Shape</u> defines a drawable convex shape.
 It also defines helper functions to draw simple shapes like lines, rectangles, circles, etc.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Shape.Type"></a>enum <u>Type</u>: uint;
</big></dt>
<dd>Supported shape types.<br><br>

<dl><dt><big><a name="Shape.Type.Quad"></a><u>Quad</u></big></dt>
<dd>Declare that the stored vertices are Quads. <br><br>

</dd>
<dt><big><a name="Shape.Type.QuadStrip"></a><u>QuadStrip</u></big></dt>
<dd>Declare that the stored vertices are Quad Strips<br><br>

</dd>
<dt><big><a name="Shape.Type.Triangle"></a><u>Triangle</u></big></dt>
<dd>Declare that the stored vertices are Triangles. <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleStrip"></a><u>TriangleStrip</u></big></dt>
<dd>Declare that the stored vertices are Triangles Strips <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleFan"></a><u>TriangleFan</u></big></dt>
<dd>Declare that the stored vertices are Triangles Fans. <br><br>

</dd>
<dt><big><a name="Shape.Type.Lines"></a><u>Lines</u></big></dt>
<dd>Declare that the stored vertices are <u>Lines</u>. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineStrip"></a><u>LineStrip</u></big></dt>
<dd>Declare that the stored vertices are Line Strips. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineLoop"></a><u>LineLoop</u></big></dt>
<dd>Declare that the stored vertices are Line Loops. <br><br>

</dd>
<dt><big><a name="Shape.Type.Polygon"></a><u>Polygon</u></big></dt>
<dd>Declare that the stored vertices are Polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.this"></a>final  this(Type <i>type</i>, Texture <i>tex</i> = null);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Shape.bindTexture"></a>final void <u>bindTexture</u>(Texture <i>tex</i>);
</big></dt>
<dd>Bind (or unbind) a Texture.<br><br>

</dd>
<dt><big><a name="Shape.setTextureRect"></a>final void <u>setTextureRect</u>(ref const ShortRect <i>texRect</i>);
</big></dt>
<dd>Set a Texture Rect<br><br>

</dd>
<dt><big><a name="Shape.setTextureRect"></a>final void <u>setTextureRect</u>(const ShortRect <i>texRect</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.fetchTextureRect"></a>final inout pure nothrow inout(ShortRect*) <u>fetchTextureRect</u>();
</big></dt>
<dd>Returns a pointer to the Texture Rect.
 With this you can change the existing Rect without setting a new one.
 You can e.g. collapse the Rect with this method.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Shape s = Shape.make(...);
<font color=green>// A lot of code
</font>s.<u>fetchTextureRect</u>().collapse();
</pre>
<br><br>

</dd>
<dt><big><a name="Shape.setSmooth"></a>final pure nothrow void <u>setSmooth</u>(Smooth.Target <i>sTarget</i>, Smooth.Mode <i>sMode</i> = Smooth.Mode.Fastest);
</big></dt>
<dd>Set target and mode of smoothing.<br><br>

</dd>
<dt><big><a name="Shape.getSmooth"></a>final const pure nothrow ref const(Smooth) <u>getSmooth</u>();
</big></dt>
<dd>Return the current smooth<br><br>

</dd>
<dt><big><a name="Shape.forceUpdate"></a>final pure nothrow void <u>forceUpdate</u>();
</big></dt>
<dd>The current shape will be updated.<br><br>

</dd>
<dt><big><a name="Shape.setType"></a>final pure nothrow void <u>setType</u>(Type <i>type</i>);
</big></dt>
<dd>Set or replace the current Shape <i>type</i>.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.getType"></a>final const pure nothrow Type <u>getType</u>();
</big></dt>
<dd>Returns the Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.setVertexColor"></a>final void <u>setVertexColor</u>(ref const Color <i>col</i>);
</big></dt>
<dd>Set for <b>all</b> vertices a (new) color.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.setVertexColor"></a>final void <u>setVertexColor</u>(const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.fill"></a>final pure nothrow void <u>fill</u>(bool <u>fill</u>);
</big></dt>
<dd>Activate <u>fill</u> mode.
 This means the whole shape is drawn and not only the outlines.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.filled"></a>final const pure nothrow bool <u>filled</u>();
</big></dt>
<dd>Returns if the fill mode is active or not.<br><br>

</dd>
<dt><big><a name="Shape.setLineWidth"></a>final pure nothrow void <u>setLineWidth</u>(ubyte <i>width</i>);
</big></dt>
<dd>Set the line <i>width</i>.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.getLineWidth"></a>final const pure nothrow ubyte <u>getLineWidth</u>();
</big></dt>
<dd>Returns the line width.<br><br>

</dd>
<dt><big><a name="Shape.append"></a>final void <u>append</u>(ref const Vertex <i>vx</i>);
</big></dt>
<dd>Stores a Vertex for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.append"></a>final void <u>append</u>(const Vertex <i>vec</i>);
</big></dt>
<dd>Rvalue version.<br><br>

</dd>
<dt><big><a name="Shape.append"></a>final void <u>append</u>(const Vertex[] <i>vertices</i>);
</big></dt>
<dd>Stores multiple Vertices for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.remove"></a>final void <u>remove</u>(uint <i>index</i>, Vertex* <i>vp</i> = null);
</big></dt>
<dd>Remove the Vertex on the specific <i>index</i>.
 If <i>vp</i> is not <b>null</b>, the droped Vertex is stored there.<br><br>

</dd>
<dt><big><a name="Shape.getVertices"></a>final const pure nothrow const(Vertex[]) <u>getVertices</u>();
</big></dt>
<dd>Returns all Vertex of this Shape.<br><br>

</dd>
<dt><big><a name="Shape.getVertexAt"></a>final const ref const(Vertex) <u>getVertexAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns the Vertex at the given index
 or throws an exception, if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.fetchVertexAt"></a>final inout inout(Vertex)* <u>fetchVertexAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a pointer of the Vertex at the given index
 or <b>null</b> if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const float[] <i>mat</i>);
</big></dt>
<dd>Add an array of floats
 Note that 3 dimensional coordinate components are expected.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Vertex[] <i>vertices</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and <i>vertices</i>.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(ubyte <i>radius</i>, const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Make a new Shape object as Circle.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
