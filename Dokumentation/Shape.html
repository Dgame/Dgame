<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphics.Shape</title>
        </head><body>
        <h1>Dgame.Graphics.Shape</h1>
        <!-- Generated by Ddoc from C:\Users\Besitzer\Documents\GitHub\Dgame\Graphics\Shape.d -->
<br><br>
<dl><dt><big><a name="Smooth"></a>struct <u>Smooth</u>;
</big></dt>
<dd><u>Smooth</u> wrapper<br><br>

<dl><dt><big><a name="Smooth.Target"></a>enum <u>Target</u>;
</big></dt>
<dd>Supported smooth targets.<br><br>

<dl><dt><big><a name="Smooth.Target.None"></a><u>None</u></big></dt>
<dd>No smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Target.Point"></a><u>Point</u></big></dt>
<dd>Enable smooth for points. <br><br>

</dd>
<dt><big><a name="Smooth.Target.Line"></a><u>Line</u></big></dt>
<dd>Enable smooth for lines. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.Hint"></a>enum <u>Hint</u>;
</big></dt>
<dd>Smooth Hints to determine
 which kind of smoothing is made.<br><br>

<dl><dt><big><a name="Smooth.Hint.DontCare"></a><u>DontCare</u></big></dt>
<dd>The OpenGL implementation decide on their own. <br><br>

</dd>
<dt><big><a name="Smooth.Hint.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> kind of smooth (default). <br><br>

</dd>
<dt><big><a name="Smooth.Hint.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but lowest kind of smooth. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Smooth.getTarget"></a>const pure nothrow Target <u>getTarget</u>();
</big></dt>
<dd>Returns the current target<br><br>

</dd>
<dt><big><a name="Smooth.getHint"></a>const pure nothrow Hint <u>getHint</u>();
</big></dt>
<dd>Return the current hint<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape"></a>class <u>Shape</u>: Dgame.Graphics.Drawable.Drawable, Dgame.Graphics.Interface.Transformable.Transformable, Dgame.Graphics.Interface.Blendable.Blendable;
</big></dt>
<dd><u>Shape</u> defines a drawable convex shape.
 It also defines helper functions to draw simple shapes like lines, rectangles, circles, etc.
<br><br>
<b>Author:</b><br>
rschuett<br><br>

<dl><dt><big><a name="Shape.Type"></a>enum <u>Type</u>;
</big></dt>
<dd>Supported shape types.<br><br>

<dl><dt><big><a name="Shape.Type.Quad"></a><u>Quad</u></big></dt>
<dd>Declare that the stored vertices are Quads. <br><br>

</dd>
<dt><big><a name="Shape.Type.QuadStrip"></a><u>QuadStrip</u></big></dt>
<dd>Declare that the stored vertices are Quad Strips<br><br>

</dd>
<dt><big><a name="Shape.Type.Triangle"></a><u>Triangle</u></big></dt>
<dd>Declare that the stored vertices are Triangles. <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleStrip"></a><u>TriangleStrip</u></big></dt>
<dd>Declare that the stored vertices are Triangles Strips <br><br>

</dd>
<dt><big><a name="Shape.Type.TriangleFan"></a><u>TriangleFan</u></big></dt>
<dd>Declare that the stored vertices are Triangles Fans. <br><br>

</dd>
<dt><big><a name="Shape.Type.Lines"></a><u>Lines</u></big></dt>
<dd>Declare that the stored vertices are <u>Lines</u>. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineStrip"></a><u>LineStrip</u></big></dt>
<dd>Declare that the stored vertices are Line Strips. <br><br>

</dd>
<dt><big><a name="Shape.Type.LineLoop"></a><u>LineLoop</u></big></dt>
<dd>Declare that the stored vertices are Line Loops. <br><br>

</dd>
<dt><big><a name="Shape.Type.Polygon"></a><u>Polygon</u></big></dt>
<dd>Declare that the stored vertices are Polygons. <br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.Update"></a>enum <u>Update</u>;
</big></dt>
<dd>Which Buffer should updated.
 Can be ORed together:
<pre class="d_code">Shape s = ...;
s.update(Shape.<u>Update</u>.Pixel | Shape.<u>Update</u>.Color);
</pre>
<br><br>
or you can use 'Both'
<br><br>

<pre class="d_code">Shape s = ...;
s.update(Shape.<u>Update</u>.Both);
</pre>
<br><br>

<dl><dt><big><a name="Shape.Update.None"></a><u>None</u></big></dt>
<dd>No buffer<br><br>

</dd>
<dt><big><a name="Shape.Update.Vertex"></a><u>Vertex</u></big></dt>
<dd>Only the <u>Vertex</u> Buffer<br><br>

</dd>
<dt><big><a name="Shape.Update.Color"></a><u>Color</u></big></dt>
<dd>Only the <u>Color</u> Buffer<br><br>

</dd>
<dt><big><a name="Shape.Update.Both"></a><u>Both</u></big></dt>
<dd><u>Both</u>, Vertex and Color Buffer<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Shape.this"></a>final  this(Type <i>type</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Shape.setAutoUpdate"></a>final void <u>setAutoUpdate</u>(bool <i>val</i>);
</big></dt>
<dd>Activate 'autoUpdate'.
 This means that which every append* or remove* method an update call is sended.
 This spare you the manual call of update, but if you have many calls which cause an update call and 'autoUpdate' is activated
 it could be more performant to disable this and handle the update call(s) by yourself.
<br><br>
<b>Note:</b><br>
Default this is disabled.
<br><br>
<b>Note:</b><br>
Methods that do not need to update call, have a  brief note.<br><br>

</dd>
<dt><big><a name="Shape.isAutoUpdate"></a>final const pure nothrow bool <u>isAutoUpdate</u>();
</big></dt>
<dd>Returns if 'autoUpdate' is enabled.
 Default is disabled.<br><br>

</dd>
<dt><big><a name="Shape.setSmooth"></a>final void <u>setSmooth</u>(Smooth.Target <i>sTarget</i>, Smooth.Hint <i>sHint</i> = Smooth.Hint.Fastest);
</big></dt>
<dd>Set target and hint of smoothing.<br><br>

</dd>
<dt><big><a name="Shape.getSmooth"></a>final const pure nothrow ref const(Smooth) <u>getSmooth</u>();
</big></dt>
<dd>Return the current smooth<br><br>

</dd>
<dt><big><a name="Shape.update"></a>final void <u>update</u>(Update <i>val</i>);
</big></dt>
<dd>The current shape will be updated.
 If 'autoUpdate' is activated, this happens automatically,
 otherwise you should use this.<br><br>

</dd>
<dt><big><a name="Shape.setType"></a>final void <u>setType</u>(Type <i>type</i>);
</big></dt>
<dd>Set or replace the current Shape <i>type</i>.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.getType"></a>final const pure nothrow Type <u>getType</u>();
</big></dt>
<dd>Returns the Shape Type.
<br><br>
<b>See:</b><br>
Shape.Type enum.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>final void <u>setPixelColor</u>(ref const Color <i>col</i>);
</big></dt>
<dd>Set for <b>all</b> vertices a (new) color.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.setPixelColor"></a>final void <u>setPixelColor</u>(const Color <i>col</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.enableFill"></a>final void <u>enableFill</u>(bool <i>fill</i>);
</big></dt>
<dd>Activate <i>fill</i> mode.
 This means the whole shape is drawn and not only the outlines.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.shouldFill"></a>final const pure nothrow bool <u>shouldFill</u>();
</big></dt>
<dd>Returns if the fill mode is active or not.<br><br>

</dd>
<dt><big><a name="Shape.setLineWidth"></a>final void <u>setLineWidth</u>(ubyte <i>width</i>);
</big></dt>
<dd>Set the line <i>width</i>.
<br><br>
<b>Note:</b><br>
This method does not need an update call.<br><br>

</dd>
<dt><big><a name="Shape.getLineWidth"></a>final const pure nothrow ubyte <u>getLineWidth</u>();
</big></dt>
<dd>Returns the line width.<br><br>

</dd>
<dt><big><a name="Shape.appendVector"></a>final void <u>appendVector</u>(ref const Vector2f <i>vec</i>);
</big></dt>
<dd>Stores Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendVector"></a>final void <u>appendVector</u>(const Vector2f <i>vec</i>);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
<dt><big><a name="Shape.appendPixel"></a>final void <u>appendPixel</u>(ref const Pixel <i>vx</i>);
</big></dt>
<dd>Stores a Pixel for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendPixels"></a>final void <u>appendPixels</u>(const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Stores multiple Vertices for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.appendVectors"></a>final void <u>appendVectors</u>(const Vector2f[] <i>vec</i>);
</big></dt>
<dd>Stores multiple Pixel coordinates for this Shape.<br><br>

</dd>
<dt><big><a name="Shape.remove"></a>final void <u>remove</u>(uint <i>index</i>, Pixel* <i>vp</i> = null);
</big></dt>
<dd>Remove the Pixel on the specific <i>index</i>.
 If <i>vp</i> is not <b>null</b>, the droped Pixel is stored there.<br><br>

</dd>
<dt><big><a name="Shape.getPixels"></a>final const pure nothrow ref const(Pixel[]) <u>getPixels</u>();
</big></dt>
<dd>Returns all Pixel of this Shape.<br><br>

</dd>
<dt><big><a name="Shape.getPixelAt"></a>final inout ref inout(Pixel) <u>getPixelAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.getVectorAt"></a>final inout ref inout(Vector2f) <u>getVectorAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel coordinates on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.getColorAt"></a>final inout ref inout(Color) <u>getColorAt</u>(uint <i>idx</i>);
</big></dt>
<dd>Returns a reference of the Pixel color on the given index
 or fail if the index is out of range.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Vector2f[] <i>vec</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.make"></a>static Shape <u>make</u>(Type <i>type</i>, const Pixel[] <i>pixels</i>);
</big></dt>
<dd>Make a new Shape object with the given <i>type</i> and vertices.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(float <i>radius</i>, ref const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Make a new Shape object as Circle.<br><br>

</dd>
<dt><big><a name="Shape.makeCircle"></a>static Shape <u>makeCircle</u>(float <i>radius</i>, const Vector2f <i>center</i>, ubyte <i>vecNum</i> = 30);
</big></dt>
<dd>Rvalue version<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
