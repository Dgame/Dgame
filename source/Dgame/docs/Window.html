<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Window.Window</title>
        </head><body>
        <h1>Dgame.Window.Window</h1>
        <!-- Generated by Ddoc from ..\Window\Window.d -->
<br><br>
<dl><dt><big><a name="Window"></a>struct <u>Window</u>;
</big></dt>
<dd><u>Window</u> is the rendering window where all drawable objects are drawn.
<br><br>
Note that the default clear-color is <code>Color.White</code> and the
 default VerticalSync is <code><u>Window</u>.VerticalSync.Disable</code>, which means the Applications runs with full FPS.

<br><br>
<b>Author:</b><br>
Randy Schuett (rswhite4@googlemail.com)<br><br>

<dl><dt><big><a name="Window.VerticalSync"></a>enum <u>VerticalSync</u>: byte;
</big></dt>
<dd>The Window syncronisation mode.
 Default VerticalSyncronisation is <code><u>VerticalSync</u>.Enable</code>.<br><br>

<dl><dt><big><a name="Window.VerticalSync.Enable"></a><u>Enable</u></big></dt>
<dd>VerticalSync is enabled<br><br>

</dd>
<dt><big><a name="Window.VerticalSync.Disable"></a><u>Disable</u></big></dt>
<dd>VerticalSync is disabled<br><br>

</dd>
<dt><big><a name="Window.VerticalSync.LateSwapTearing"></a><u>LateSwapTearing</u></big></dt>
<dd>For late swap tearing<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Window.Style"></a>enum <u>Style</u>: int;
</big></dt>
<dd>The specific window styles<br><br>

<dl><dt><big><a name="Window.Style.Fullscreen"></a><u>Fullscreen</u></big></dt>
<dd>Window is fullscreened<br><br>

</dd>
<dt><big><a name="Window.Style.Desktop"></a><u>Desktop</u></big></dt>
<dd>Window has <u>Desktop</u> Fullscreen<br><br>

</dd>
<dt><big><a name="Window.Style.OpenGL"></a><u>OpenGL</u></big></dt>
<dd><u>OpenGL</u> support<br><br>

</dd>
<dt><big><a name="Window.Style.Shown"></a><u>Shown</u></big></dt>
<dd>Show the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Borderless"></a><u>Borderless</u></big></dt>
<dd>Hide the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Resizeable"></a><u>Resizeable</u></big></dt>
<dd>Window is resizeable<br><br>

</dd>
<dt><big><a name="Window.Style.Maximized"></a><u>Maximized</u></big></dt>
<dd>Maximize the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Minimized"></a><u>Minimized</u></big></dt>
<dd>Minimize the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.InputGrabbed"></a><u>InputGrabbed</u></big></dt>
<dd>Grab the input inside the window<br><br>

</dd>
<dt><big><a name="Window.Style.InputFocus"></a><u>InputFocus</u></big></dt>
<dd>The Window has input (keyboard) focus<br><br>

</dd>
<dt><big><a name="Window.Style.MouseFocus"></a><u>MouseFocus</u></big></dt>
<dd>The Window has mouse focus<br><br>

</dd>
<dt><big><a name="Window.Style.MouseCapture"></a><u>MouseCapture</u></big></dt>
<dd>window has mouse captured (unrelated to InputGrabbed)<br><br>

</dd>
<dt><big><a name="Window.Style.HighDPI"></a><u>HighDPI</u></big></dt>
<dd>Window should be created in high-DPI mode if supported<br><br>

</dd>
<dt><big><a name="Window.Style.Foreign"></a><u>Foreign</u></big></dt>
<dd>The window was created by some other framework.<br><br>

</dd>
<dt><big><a name="Window.Style.Default"></a><u>Default</u></big></dt>
<dd><u>Default</u> mode is Shown | OpenGL | HighDPI<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Window.projection"></a>Matrix4x4 <u>projection</u>;
</big></dt>
<dd>The current <u>projection</u> Matrix
<br><br>
<b>Note:</b><br>
This is intended for advanced users only.

<br><br>
<b>See:</b><br>
Matrix4x4<br><br>

</dd>
<dt><big><a name="Window.this"></a>this(uint <i>width</i>, uint <i>height</i>, string <i>title</i>, uint <i>style</i> = Style.Default, GLSettings <i>gl</i> = GLSettings.init);
</big></dt>
<dd>CTor
 Position of the Window is default 100x, 100y and the VerticalSync is disabled<br><br>

</dd>
<dt><big><a name="Window.this.2"></a>this()(auto ref const DisplayMode <i>mode</i>, string <i>title</i>, uint <i>style</i> = Style.Default, GLSettings <i>gl</i> = GLSettings.init);
</big></dt>
<dd>CTor
 Position is at 100x, 100y and the VerticalSync is enabled, if mode.refreshRate &gt; 0<br><br>

</dd>
<dt><big><a name="Window.this.3"></a>this()(auto ref const Rect <i>view</i>, string <i>title</i>, uint <i>style</i> = Style.Default, GLSettings <i>gl</i> = GLSettings.init);
</big></dt>
<dd>CTor
 Position is specifiable and the VerticalSync is disabled<br><br>

</dd>
<dt><big><a name="Window.loadProjection"></a>const nothrow @nogc void <u>loadProjection</u>();
</big></dt>
<dd>Load the projection Matrix, so that any change / transformation of the Matrix will now be visible<br><br>

</dd>
<dt><big><a name="Window.setClearColor"></a>const nothrow @nogc void <u>setClearColor</u>()(auto ref const Color4b <i>col</i>);
</big></dt>
<dd>Set the color which this windows use to clear the buffer.
 This is also the background color of the window.<br><br>

</dd>
<dt><big><a name="Window.clear"></a>const nothrow @nogc void <u>clear</u>();
</big></dt>
<dd>Clears the screen with the color you specified in setClearColor<br><br>

</dd>
<dt><big><a name="Window.setVerticalSync"></a>const nothrow @nogc bool <u>setVerticalSync</u>(VerticalSync <i>sync</i>);
</big></dt>
<dd>Set the VerticalSyncronisation mode of this window.
 Default VerticalSyncronisation is <code>VerticalSync.Enable</code>.
<br><br>
<b>See:</b><br>
VerticalSync enum
<br><br>

 Returns if the <i>sync</i> mode is supported.<br><br>

</dd>
<dt><big><a name="Window.getVerticalSync"></a>nothrow @nogc VerticalSync <u>getVerticalSync</u>();
</big></dt>
<dd>Returns the current syncronisation mode.
<br><br>
<b>See:</b><br>
VerticalSync enum<br><br>

</dd>
<dt><big><a name="Window.capture"></a>nothrow @nogc Surface <u>capture</u>(Texture.Format <i>fmt</i> = Texture.Format.BGRA);
</big></dt>
<dd>Capture the pixel data of the current window and
 returns a Surface with this pixel data.
 You can also alter the format of the pixel data.
 Default is <code>Texture.Format.BGRA</code>.
 This method is predestinated for screenshots.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Window wnd = ...
...
wnd.<u>capture</u>().saveToFile(<font color=red>"samples/img/screenshot.png"</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Window.restore"></a>nothrow @nogc void <u>restore</u>();
</big></dt>
<dd>Restore the size and position, if the Window is minimized or maximized.<br><br>

</dd>
<dt><big><a name="Window.raise"></a>nothrow @nogc void <u>raise</u>();
</big></dt>
<dd>Raises the Window above other Windows and set the input focus.<br><br>

</dd>
<dt><big><a name="Window.maximize"></a>nothrow @nogc void <u>maximize</u>();
</big></dt>
<dd>Make the window as large as possible.<br><br>

</dd>
<dt><big><a name="Window.minimize"></a>nothrow @nogc void <u>minimize</u>();
</big></dt>
<dd>Minimize the Window to an iconic representation.<br><br>

</dd>
<dt><big><a name="Window.setBorder"></a>nothrow @nogc void <u>setBorder</u>(bool <i>enable</i>);
</big></dt>
<dd>Set the border state of the Window.<br><br>

</dd>
<dt><big><a name="Window.hasKeyboardFocus"></a>const nothrow @nogc bool <u>hasKeyboardFocus</u>();
</big></dt>
<dd>Returns if the keyboard focus is on this window.<br><br>

</dd>
<dt><big><a name="Window.hasMouseFocus"></a>const nothrow @nogc bool <u>hasMouseFocus</u>();
</big></dt>
<dd>Returns if the mouse focus is on this window.<br><br>

</dd>
<dt><big><a name="Window.setPosition"></a>nothrow @nogc void <u>setPosition</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>Set a new position to this window<br><br>

</dd>
<dt><big><a name="Window.setPosition.2"></a>nothrow @nogc void <u>setPosition</u>()(auto ref const Vector2i <i>vec</i>);
</big></dt>
<dd>Set a new position to this window<br><br>

</dd>
<dt><big><a name="Window.getPosition"></a>nothrow @nogc Vector2i <u>getPosition</u>();
</big></dt>
<dd>Returns the current position of the window.<br><br>

</dd>
<dt><big><a name="Window.setSize"></a>nothrow @nogc void <u>setSize</u>(uint <i>width</i>, uint <i>height</i>);
</big></dt>
<dd>Set a new size to this window<br><br>

</dd>
<dt><big><a name="Window.setSize.2"></a>nothrow @nogc void <u>setSize</u>()(auto ref const Size <i>size</i>);
</big></dt>
<dd>Set a new size to this window<br><br>

</dd>
<dt><big><a name="Window.getSize"></a>nothrow @nogc Size <u>getSize</u>();
</big></dt>
<dd>Returns the size (width and height) of the Window<br><br>

</dd>
<dt><big><a name="Window.getDrawableSize"></a>nothrow @nogc Size <u>getDrawableSize</u>();
</big></dt>
<dd>Returns the size of the underlying drawable area (e.g. for use with glViewport).
 This method may only differ from getSize if you are using High-DPI.<br><br>

</dd>
<dt><big><a name="Window.setMinimumSize"></a>nothrow @nogc void <u>setMinimumSize</u>(uint <i>width</i>, uint <i>height</i>);
</big></dt>
<dd>Set the minimum Size for the Window<br><br>

</dd>
<dt><big><a name="Window.setMinimumSize.2"></a>nothrow @nogc void <u>setMinimumSize</u>()(auto ref const Size <i>size</i>);
</big></dt>
<dd>Set the minimum Size for the Window<br><br>

</dd>
<dt><big><a name="Window.getMinimumSize"></a>nothrow @nogc Size <u>getMinimumSize</u>();
</big></dt>
<dd>Returns the minimum Size of the Window<br><br>

</dd>
<dt><big><a name="Window.setMaximumSize"></a>nothrow @nogc void <u>setMaximumSize</u>(uint <i>width</i>, uint <i>height</i>);
</big></dt>
<dd>Set the maximum Size of the Window<br><br>

</dd>
<dt><big><a name="Window.setMaximumSize.2"></a>nothrow @nogc void <u>setMaximumSize</u>()(auto ref const Size <i>size</i>);
</big></dt>
<dd>Set the maximum Size of the Window<br><br>

</dd>
<dt><big><a name="Window.getMaximumSize"></a>nothrow @nogc Size <u>getMaximumSize</u>();
</big></dt>
<dd>Returns the maximum Size of the Window<br><br>

</dd>
<dt><big><a name="Window.getStyle"></a>nothrow @nogc uint <u>getStyle</u>();
</big></dt>
<dd>Returns the Window Style.
<br><br>
<b>See:</b><br>
Style enum<br><br>

</dd>
<dt><big><a name="Window.poll"></a>const nothrow @nogc bool <u>poll</u>(Event* <i>event</i>);
</big></dt>
<dd>Update the parameter <i>event</i> and set the data of the current <i>event</i> in it.
<br><br>
<b>Returns:</b><br>
<b>true</b>, if there was a valid <i>event</i> and <b>false</b> if not.<br><br>

</dd>
<dt><big><a name="Window.wait"></a>const nothrow @nogc bool <u>wait</u>(Event* <i>event</i>, int <i>timeout</i> = -1);
</big></dt>
<dd>Waits for the given Event.
 If the seconds parameter is greater then -1, it waits maximal <i>timeout</i> seconds.<br><br>

</dd>
<dt><big><a name="Window.push"></a>const nothrow @nogc bool <u>push</u>(Event.Type <i>type</i>);
</big></dt>
<dd>Push an event of the given <i>type</i> inside the Event queue.
<br><br>
<b>Returns:</b><br>
if the <u>push</u> was successfull or not.<br><br>

</dd>
<dt><big><a name="Window.hasEvent"></a>const nothrow @nogc bool <u>hasEvent</u>(Event.Type <i>type</i>);
</big></dt>
<dd><b>Returns:</b><br>
if inside of the Event Queue is an Event of the given <i>type</i>.<br><br>

</dd>
<dt><big><a name="Window.hasQuitEvent"></a>const nothrow @nogc bool <u>hasQuitEvent</u>();
</big></dt>
<dd><b>Returns:</b><br>
if the current Event queue has the Quit Event.<br><br>

</dd>
<dt><big><a name="Window.draw"></a>const nothrow @nogc void <u>draw</u>(Drawable <i>d</i>);
</big></dt>
<dd>Draw a drawable object on screen<br><br>

</dd>
<dt><big><a name="Window.display"></a>nothrow @nogc void <u>display</u>();
</big></dt>
<dd>Make all changes visible on screen<br><br>

</dd>
<dt><big><a name="Window.getTitle"></a>nothrow @nogc string <u>getTitle</u>();
</big></dt>
<dd>Returns the current title of the window.<br><br>

</dd>
<dt><big><a name="Window.setTitle"></a>nothrow @nogc string <u>setTitle</u>(string <i>title</i>);
</big></dt>
<dd>Set a new <i>title</i> to this window
<br><br>
<b>Returns:</b><br>
the old <i>title</i><br><br>

</dd>
<dt><big><a name="Window.setIcon"></a>@nogc void <u>setIcon</u>(ref Surface <i>srfc</i>);
</big></dt>
<dd>Set an icon for this window.<br><br>

</dd>
<dt><big><a name="Window.getDisplayIndex"></a>nothrow @nogc int <u>getDisplayIndex</u>();
</big></dt>
<dd>Returns the index of the display which contains the center of the window
<br><br>
<b>Note:</b><br>
If something went wrong (e.g. your Window is invalid), a negative value is returned<br><br>

</dd>
<dt><big><a name="Window.setDisplayMode"></a>nothrow @nogc void <u>setDisplayMode</u>()(auto ref const DisplayMode <i>mode</i>);
</big></dt>
<dd>Set the DisplayMode when the Window is visible at fullscreen.<br><br>

</dd>
<dt><big><a name="Window.getDisplayMode"></a>nothrow @nogc DisplayMode <u>getDisplayMode</u>();
</big></dt>
<dd>Returns the DisplayMode when the Window is visible at fullscreen.<br><br>

</dd>
<dt><big><a name="Window.setFullscreen"></a>nothrow @nogc bool <u>setFullscreen</u>(uint <i>style</i>, bool <i>adaptProjection</i> = true);
</big></dt>
<dd>Use this function to (re)set Window's fullscreen states.
<br><br>
<i>style</i> may be Style.Fullscreen for "real" fullscreen with a display mode change
 or Style.Desktop for "fake" fullscreen that takes the size of the desktop
 Use 0 for windowed mode.
<br><br>

 if <i>adaptProjection</i> is <b>true</b> (which is the default) the projection will automatically adapted.
 set it to <b>false</b> if you want to specify your own projection afterwards.<br><br>

</dd>
<dt><big><a name="Window.toggleFullscreen"></a>nothrow @nogc void <u>toggleFullscreen</u>(bool <i>adaptProjection</i> = true);
</big></dt>
<dd>Toggle between Fullscreen and windowed mode, depending on the current state.
<br><br>
if <i>adaptProjection</i> is <b>true</b> (which is the default) the projection will automatically adapted.
 set it to <b>false</b> if you want to specify your own projection afterwards.<br><br>

</dd>
<dt><big><a name="Window.isFullscreen"></a>nothrow @nogc bool <u>isFullscreen</u>();
</big></dt>
<dd>Returns, if this Window is in fullscreen mode.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
