<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphic.Texture</title>
        </head><body>
        <h1>Dgame.Graphic.Texture</h1>
        <!-- Generated by Ddoc from ..\Graphic\Texture.d -->
<br><br>
<dl><dt><big><a name="Texture"></a>struct <u>Texture</u>;
</big></dt>
<dd>A <u>Texture</u> is a 2 dimensional pixel reprasentation.
 It is a wrapper of an OpenGL <u>Texture</u>.
<br><br>
<b>Author:</b><br>
Randy Schuett (rswhite4@googlemail.com)<br><br>

<dl><dt><big><a name="Texture.Format"></a>enum <u>Format</u>: int;
</big></dt>
<dd>Supported Texture <u>Format</u><br><br>

<dl><dt><big><a name="Texture.Format.None"></a><u>None</u></big></dt>
<dd>Take this if you want to declare that you give no Format.<br><br>

</dd>
<dt><big><a name="Texture.Format.RGB"></a><u>RGB</u></big></dt>
<dd>Alias for GL_RGB<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA"></a><u>RGBA</u></big></dt>
<dd>Alias for GL_RGBA<br><br>

</dd>
<dt><big><a name="Texture.Format.BGR"></a><u>BGR</u></big></dt>
<dd>Alias for GL_BGR<br><br>

</dd>
<dt><big><a name="Texture.Format.BGRA"></a><u>BGRA</u></big></dt>
<dd>Alias for GL_BGRA<br><br>

</dd>
<dt><big><a name="Texture.Format.RGB8"></a><u>RGB8</u></big></dt>
<dd>8 Bit RGB Format<br><br>

</dd>
<dt><big><a name="Texture.Format.RGB16"></a><u>RGB16</u></big></dt>
<dd>16 Bit RGB Format<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA8"></a><u>RGBA8</u></big></dt>
<dd>8 Bit RGBA Format<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA16"></a><u>RGBA16</u></big></dt>
<dd>16 Bit RGBA Format<br><br>

</dd>
<dt><big><a name="Texture.Format.Alpha"></a><u>Alpha</u></big></dt>
<dd>Alias for GL_ALPHA<br><br>

</dd>
<dt><big><a name="Texture.Format.Luminance"></a><u>Luminance</u></big></dt>
<dd>Alias for GL_LUMINANCE<br><br>

</dd>
<dt><big><a name="Texture.Format.LuminanceAlpha"></a><u>LuminanceAlpha</u></big></dt>
<dd>Alias for GL_LUMINANCE_ALPHA<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture.this"></a>nothrow @nogc this(void* <i>memory</i>, uint <i>width</i>, uint <i>height</i>, Format <i>fmt</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.this.2"></a>nothrow @nogc this(const Surface <i>srfc</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.currentlyBound"></a>static nothrow @nogc int <u>currentlyBound</u>();
</big></dt>
<dd>Returns the currently bound texture id.<br><br>

</dd>
<dt><big><a name="Texture.id"></a>const pure nothrow @nogc @property uint <u>id</u>();
</big></dt>
<dd>Returns the Texture Id.<br><br>

</dd>
<dt><big><a name="Texture.isValid"></a>const pure nothrow @nogc bool <u>isValid</u>();
</big></dt>
<dd>Returns if the texture is used.<br><br>

</dd>
<dt><big><a name="Texture.width"></a>const pure nothrow @nogc @property uint <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u> of this Texture<br><br>

</dd>
<dt><big><a name="Texture.height"></a>const pure nothrow @nogc @property uint <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u> of this Texture.<br><br>

</dd>
<dt><big><a name="Texture.depth"></a>const pure nothrow @nogc @property ubyte <u>depth</u>();
</big></dt>
<dd>Returns the <u>depth</u>. May often 24 or 32.<br><br>

</dd>
<dt><big><a name="Texture.format"></a>const pure nothrow @nogc @property Format <u>format</u>();
</big></dt>
<dd>Returns the Format.
<br><br>
<b>See:</b><br>
Format enum.<br><br>

</dd>
<dt><big><a name="Texture.bind"></a>const nothrow @nogc void <u>bind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now activated.<br><br>

</dd>
<dt><big><a name="Texture.unbind"></a>const nothrow @nogc void <u>unbind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now deactivated.<br><br>

</dd>
<dt><big><a name="Texture.isCurrentlyBound"></a>const nothrow @nogc bool <u>isCurrentlyBound</u>();
</big></dt>
<dd>Returns <b>true</b>, if this Texture is currently activated.<br><br>

</dd>
<dt><big><a name="Texture.setSmooth"></a>nothrow @nogc void <u>setSmooth</u>(bool <i>smooth</i>);
</big></dt>
<dd>Set <i>smooth</i> filter.<br><br>

</dd>
<dt><big><a name="Texture.isSmooth"></a>const pure nothrow @nogc bool <u>isSmooth</u>();
</big></dt>
<dd>Returns if smooth filter are activated.<br><br>

</dd>
<dt><big><a name="Texture.setRepeat"></a>nothrow @nogc void <u>setRepeat</u>(bool <i>repeat</i>);
</big></dt>
<dd>Set repeating.<br><br>

</dd>
<dt><big><a name="Texture.isRepeated"></a>const pure nothrow @nogc bool <u>isRepeated</u>();
</big></dt>
<dd>Returns if repeating is enabled.<br><br>

</dd>
<dt><big><a name="Texture.loadFrom"></a>nothrow @nogc void <u>loadFrom</u>(const Surface <i>srfc</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Load from Surface<br><br>

</dd>
<dt><big><a name="Texture.loadFromMemory"></a>nothrow @nogc void <u>loadFromMemory</u>(const void* <i>memory</i>, uint <i>width</i>, uint <i>height</i>, Format <i>fmt</i>);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>nothrow @nogc void <u>setColorkey</u>(const Color4b <i>colorkey</i>);
</big></dt>
<dd>Set a <i>colorkey</i>.<br><br>

</dd>
<dt><big><a name="Texture.getByteSize"></a>const pure nothrow @nogc size_t <u>getByteSize</u>();
</big></dt>
<dd>Returns the byte size of the Texture<br><br>

</dd>
<dt><big><a name="Texture.getPixels"></a>const nothrow @nogc void[] <u>getPixels</u>(void[] <i>pixels</i>);
</big></dt>
<dd>Returns the pixel data of this Texture or <b>null</b> if this Texture isn't valid.
 <i>pixels</i> is used to store the pixel data.<br><br>

</dd>
<dt><big><a name="Texture.getPixels.2"></a>const nothrow void[] <u>getPixels</u>();
</big></dt>
<dd>Returns the pixel of this Texture or <b>null</b> if this Texture isn't valid.
<br><br>
<b>Note:</b><br>
this method <b>allocates</b> GC memory.<br><br>

</dd>
<dt><big><a name="Texture.update"></a>const nothrow @nogc void <u>update</u>(const void* <i>memory</i>, const Rect* <i>rect</i> = null, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Update the pixel data of this Texture.
 The second parameter is a pointer to the area which is updated.
 If it is <b>null</b> (default) the whole Texture will be updated.
 The third parameter is the format of the pixels.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="formatToBits"></a>pure nothrow @nogc ubyte <u>formatToBits</u>(Texture.Format <i>fmt</i>);
</big></dt>
<dd>Format a Texture.Format into the related bit count.
 If the format is not supported, it returns 0.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGBA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGB) == 24);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGRA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGR) == 24);
</pre>
<br><br>

</dd>
<dt><big><a name="bitsToFormat"></a>pure nothrow @nogc Texture.Format <u>bitsToFormat</u>(ubyte <i>bits</i>, bool <i>reverse</i> = false);
</big></dt>
<dd>Format a bit count into the related Texture.Format.
 If no bit count is supported, it returns Texture.Format.None.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>bitsToFormat</u>(32) == Texture.Format.RGBA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24) == Texture.Format.RGB);
<font color=blue>assert</font>(<u>bitsToFormat</u>(32, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24, <font color=blue>true</font>) == Texture.Format.BGR);
</pre>
<br><br>

</dd>
<dt><big><a name="switchFormat"></a>pure nothrow @nogc Texture.Format <u>switchFormat</u>(Texture.Format <i>fmt</i>, bool <i>alpha</i> = false);
</big></dt>
<dd>Switch/Reverse Texture.Format.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB) == Texture.Format.BGR);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA, <font color=blue>true</font>) == Texture.Format.BGRA);
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
