<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphic.Surface</title>
        </head><body>
        <h1>Dgame.Graphic.Surface</h1>
        <!-- Generated by Ddoc from ..\Graphic\Surface.d -->
<br><br>
<dl><dt><big><a name="Surface"></a>struct <u>Surface</u>;
</big></dt>
<dd><u>Surface</u> is a wrapper for a SDL_Surface and can load and save images.
<br><br>
<b>Author:</b><br>
Randy Schuett (rswhite4@googlemail.com)<br><br>

<dl><dt><big><a name="Surface.BlendMode"></a>enum <u>BlendMode</u>: ubyte;
</big></dt>
<dd>Supported BlendModes<br><br>

<dl><dt><big><a name="Surface.BlendMode.None"></a><u>None</u></big></dt>
<dd>no blending<br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Blend"></a><u>Blend</u></big></dt>
<dd>dst = (src * A) + (dst * (1-A))<br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Add"></a><u>Add</u></big></dt>
<dd>dst = (src * A) + dst<br><br>

</dd>
<dt><big><a name="Surface.BlendMode.Mod"></a><u>Mod</u></big></dt>
<dd>dst = src * dst<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Surface.this"></a>nothrow @nogc this(SDL_Surface* <i>srfc</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Surface.this.2"></a>nothrow @nogc this(string <i>filename</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Surface.this.3"></a>nothrow @nogc this(uint <i>width</i>, uint <i>height</i>, ubyte <i>depth</i> = 32, const Masks <i>masks</i> = Masks.init);
</big></dt>
<dd>Make a new Surface of the given <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.this.4"></a>nothrow @nogc this(void* <i>memory</i>, uint <i>width</i>, uint <i>height</i>, ubyte <i>depth</i> = 32, const Masks <i>masks</i> = Masks.init);
</big></dt>
<dd>Make an new Surface of the given <i>memory</i>, <i>width</i>, <i>height</i> and <i>depth</i>.<br><br>

</dd>
<dt><big><a name="Surface.refCount"></a>const pure nothrow @nogc @property int <u>refCount</u>();
</big></dt>
<dd>Returns the current ref count / usage<br><br>

</dd>
<dt><big><a name="Surface.isValid"></a>const pure nothrow @nogc bool <u>isValid</u>();
</big></dt>
<dd>Returns if the Surface is valid. Which means that the Surface has valid data.<br><br>

</dd>
<dt><big><a name="Surface.loadFromFile"></a>nothrow @nogc bool <u>loadFromFile</u>(string <i>filename</i>);
</big></dt>
<dd>Load from <i>filename</i>. If any data is already stored, the data will be freed.<br><br>

</dd>
<dt><big><a name="Surface.loadFromMemory"></a>nothrow @nogc bool <u>loadFromMemory</u>(void* <i>memory</i>, ushort <i>width</i>, ushort <i>height</i>, ubyte <i>depth</i> = 32, const Masks <i>masks</i> = Masks.init);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Surface.saveToFile"></a>nothrow @nogc bool <u>saveToFile</u>(string <i>filename</i>);
</big></dt>
<dd>Save the current pixel data to the file.<br><br>

</dd>
<dt><big><a name="Surface.fill"></a>nothrow @nogc void <u>fill</u>(const Color4b <i>col</i>, const Rect* <i>rect</i> = null);
</big></dt>
<dd>Fills a specific area of the surface with the given color.
 The second parameter is a pointer to the area.
 If it's <b>null</b>, the whole Surface is filled.<br><br>

</dd>
<dt><big><a name="Surface.optimizeRLE"></a>nothrow @nogc bool <u>optimizeRLE</u>(bool <i>enable</i>);
</big></dt>
<dd>Use this function to set the RLE acceleration hint for a surface.
 RLE (Run-Length-Encoding) is a way of compressing data.
 If RLE is enabled, color key and alpha blending blits are much faster,
 but the surface must be locked before directly accessing the pixels.
<br><br>
<b>Returns:</b><br>
whether the call succeeded or not<br><br>

</dd>
<dt><big><a name="Surface.lock"></a>nothrow @nogc bool <u>lock</u>();
</big></dt>
<dd>Use this function to set up a surface for directly accessing the pixels.
<br><br>
<b>Returns:</b><br>
whether the call succeeded or not<br><br>

</dd>
<dt><big><a name="Surface.unlock"></a>nothrow @nogc void <u>unlock</u>();
</big></dt>
<dd>Use this function to release a surface after directly accessing the pixels.<br><br>

</dd>
<dt><big><a name="Surface.isLocked"></a>const pure nothrow @nogc bool <u>isLocked</u>();
</big></dt>
<dd>Returns whether this Surface is locked or not.<br><br>

</dd>
<dt><big><a name="Surface.mustLock"></a>nothrow @nogc bool <u>mustLock</u>();
</big></dt>
<dd>Use this function to determine whether a surface must be locked for access.<br><br>

</dd>
<dt><big><a name="Surface.adaptTo"></a>nothrow @nogc bool <u>adaptTo</u>(ref Surface <i>srfc</i>);
</big></dt>
<dd>Use this function to adapt the format of another Surface to this surface.<br><br>

</dd>
<dt><big><a name="Surface.adaptTo.2"></a>nothrow @nogc bool <u>adaptTo</u>(ubyte <i>depth</i>);
</big></dt>
<dd>Use this function to adapt the format of another Surface <i>depth</i> to this surface.<br><br>

</dd>
<dt><big><a name="Surface.setColorkey"></a>nothrow @nogc void <u>setColorkey</u>(const Color4b <i>col</i>);
</big></dt>
<dd>Set the colorkey.<br><br>

</dd>
<dt><big><a name="Surface.getColorkey"></a>nothrow @nogc Color4b <u>getColorkey</u>();
</big></dt>
<dd>Returns the current colorkey,
 or Color4b.Black, if the Surface is invalid<br><br>

</dd>
<dt><big><a name="Surface.setAlphaMod"></a>nothrow @nogc void <u>setAlphaMod</u>(ubyte <i>alpha</i>);
</big></dt>
<dd>Set the Alpha mod.<br><br>

</dd>
<dt><big><a name="Surface.getAlphaMod"></a>nothrow @nogc ubyte <u>getAlphaMod</u>();
</big></dt>
<dd>Returns the current Alpha mod.<br><br>

</dd>
<dt><big><a name="Surface.setBlendMode"></a>nothrow @nogc void <u>setBlendMode</u>(BlendMode <i>mode</i>);
</big></dt>
<dd>Set the Blendmode.<br><br>

</dd>
<dt><big><a name="Surface.getBlendMode"></a>nothrow @nogc BlendMode <u>getBlendMode</u>();
</big></dt>
<dd>Returns the current Blendmode.<br><br>

</dd>
<dt><big><a name="Surface.getClipRect"></a>nothrow @nogc Rect <u>getClipRect</u>();
</big></dt>
<dd>Returns the clip rect of this surface.
 The clip rect is the area of the surface which is drawn.<br><br>

</dd>
<dt><big><a name="Surface.setClipRect"></a>nothrow @nogc void <u>setClipRect</u>(const Rect <i>clip</i>);
</big></dt>
<dd>Set the <i>clip</i> rect.<br><br>

</dd>
<dt><big><a name="Surface.width"></a>const pure nothrow @nogc @property int <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u>.<br><br>

</dd>
<dt><big><a name="Surface.height"></a>const pure nothrow @nogc @property int <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u>.<br><br>

</dd>
<dt><big><a name="Surface.pixels"></a>inout pure nothrow @nogc @property inout(void*) <u>pixels</u>();
</big></dt>
<dd>Returns the pixel data of this surface.<br><br>

</dd>
<dt><big><a name="Surface.bits"></a>const pure nothrow @nogc @property ubyte <u>bits</u>();
</big></dt>
<dd>Count the <u>bits</u> of this surface.
 Could be 32, 24, 16, 8, 0.<br><br>

</dd>
<dt><big><a name="Surface.bytes"></a>const pure nothrow @nogc @property ubyte <u>bytes</u>();
</big></dt>
<dd>Count the <u>bytes</u> of this surface.
 Could be 4, 3, 2, 1, 0. (countBits / 8)<br><br>

</dd>
<dt><big><a name="Surface.pitch"></a>const pure nothrow @nogc @property int <u>pitch</u>();
</big></dt>
<dd>Returns the Surface <u>pitch</u> or 0.<br><br>

</dd>
<dt><big><a name="Surface.getMasks"></a>const pure nothrow @nogc Masks <u>getMasks</u>();
</big></dt>
<dd>Returns the Surface color Masks<br><br>

</dd>
<dt><big><a name="Surface.getPixelAt"></a>const nothrow @nogc int <u>getPixelAt</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>Returns the pixel at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.getPixelAt.2"></a>const nothrow @nogc int <u>getPixelAt</u>(const Vector2i <i>pos</i>);
</big></dt>
<dd>Returns the pixel at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.putPixelAt"></a>nothrow @nogc void <u>putPixelAt</u>(const Vector2i <i>pos</i>, uint <i>pixel</i>);
</big></dt>
<dd>Put a new <i>pixel</i> at the given coordinates.<br><br>

</dd>
<dt><big><a name="Surface.getColorAt"></a>const nothrow @nogc Color4b <u>getColorAt</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>Returns the color on the given position,
 or Color4b.Black if the position is out of range.<br><br>

</dd>
<dt><big><a name="Surface.getColorAt.2"></a>const nothrow @nogc Color4b <u>getColorAt</u>(const Vector2i <i>pos</i>);
</big></dt>
<dd>Returns the color on the given position.<br><br>

</dd>
<dt><big><a name="Surface.blitScaled"></a>nothrow @nogc bool <u>blitScaled</u>(ref Surface <i>srfc</i>, const Rect* <i>src</i> = null, Rect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform a fast, low quality,
 stretch blit between two surfaces of the same pixel format.
 <i>src</i> is the a pointer to a Rect structure which represents the rectangle to be copied,
 or <b>null</b> to copy the entire surface.
 <i>dst</i> is a pointer to a Rect structure which represents the rectangle that is copied into.
 <b>null</b> means, that the whole <i>srfc</i> is copied to (0|0).<br><br>

</dd>
<dt><big><a name="Surface.blit"></a>nothrow @nogc bool <u>blit</u>(ref Surface <i>srfc</i>, const Rect* <i>src</i> = null, Rect* <i>dst</i> = null);
</big></dt>
<dd>Use this function to perform a fast <u>blit</u> from the source surface to the this surface.
 <i>src</i> is the a pointer to a Rect structure which represents the rectangle to be copied,
 or <b>null</b> to copy the entire surface.
 <i>dst</i> is a pointer to a Rect structure which represents the rectangle that is copied into.
 <b>null</b> means, that the whole <i>srfc</i> is copied to (0|0).<br><br>

</dd>
<dt><big><a name="Surface.subSurface"></a>nothrow @nogc Surface <u>subSurface</u>(const Rect <i>rect</i>);
</big></dt>
<dd>Returns a subsurface from this surface. <i>rect</i> represents the viewport.
 The subsurface is a separate Surface object.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
