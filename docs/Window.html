<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Window.Window</title>
        </head><body>
        <h1>Dgame.Window.Window</h1>
        <!-- Generated by Ddoc from ..\Window\Window.d -->
<br><br>
<dl><dt><big><a name="Window"></a>struct <u>Window</u>;
</big></dt>
<dd><u>Window</u> is the rendering window where all drawable objects are drawn.
<br><br>
Note that the default clear-color is <code>Color.White</code> and the
 default Sync is <code><u>Window</u>.Sync.Disables</code>, which means the Applications runs with full FPS.

<br><br>
<b>Author:</b><br>
Randy Schuett (rswhite4@googlemail.com)<br><br>

<dl><dt><big><a name="Window.Sync"></a>enum <u>Sync</u>: byte;
</big></dt>
<dd>The Window syncronisation mode.
 Default Syncronisation is <code><u>Sync</u>.Enable</code>.<br><br>

<dl><dt><big><a name="Window.Sync.Enable"></a><u>Enable</u></big></dt>
<dd>Sync is enabled<br><br>

</dd>
<dt><big><a name="Window.Sync.Disable"></a><u>Disable</u></big></dt>
<dd>Sync is disabled<br><br>

</dd>
<dt><big><a name="Window.Sync.LateSwapTearing"></a><u>LateSwapTearing</u></big></dt>
<dd>For late swap tearing<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Window.Style"></a>enum <u>Style</u>: int;
</big></dt>
<dd>The specific window styles<br><br>

<dl><dt><big><a name="Window.Style.Fullscreen"></a><u>Fullscreen</u></big></dt>
<dd>Window is fullscreened<br><br>

</dd>
<dt><big><a name="Window.Style.Desktop"></a><u>Desktop</u></big></dt>
<dd>Window has <u>Desktop</u> Fullscreen<br><br>

</dd>
<dt><big><a name="Window.Style.OpenGL"></a><u>OpenGL</u></big></dt>
<dd><u>OpenGL</u> support<br><br>

</dd>
<dt><big><a name="Window.Style.Shown"></a><u>Shown</u></big></dt>
<dd>Show the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Borderless"></a><u>Borderless</u></big></dt>
<dd>Hide the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Resizeable"></a><u>Resizeable</u></big></dt>
<dd>Window is resizeable<br><br>

</dd>
<dt><big><a name="Window.Style.Maximized"></a><u>Maximized</u></big></dt>
<dd>Maximize the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.Minimized"></a><u>Minimized</u></big></dt>
<dd>Minimize the Window immediately<br><br>

</dd>
<dt><big><a name="Window.Style.InputGrabbed"></a><u>InputGrabbed</u></big></dt>
<dd>Grab the input inside the window<br><br>

</dd>
<dt><big><a name="Window.Style.InputFocus"></a><u>InputFocus</u></big></dt>
<dd>The Window has input (keyboard) focus<br><br>

</dd>
<dt><big><a name="Window.Style.MouseFocus"></a><u>MouseFocus</u></big></dt>
<dd>The Window has mouse focus<br><br>

</dd>
<dt><big><a name="Window.Style.MouseCapture"></a><u>MouseCapture</u></big></dt>
<dd>window has mouse captured (unrelated to InputGrabbed)<br><br>

</dd>
<dt><big><a name="Window.Style.HighDPI"></a><u>HighDPI</u></big></dt>
<dd>Window should be created in high-DPI mode if supported<br><br>

</dd>
<dt><big><a name="Window.Style.Foreign"></a><u>Foreign</u></big></dt>
<dd>The window was created by some other framework.<br><br>

</dd>
<dt><big><a name="Window.Style.Default"></a><u>Default</u></big></dt>
<dd><u>Default</u> mode is Shown | OpenGL | HighDPI<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Window.this"></a>this(uint <i>width</i>, uint <i>height</i>, string <i>title</i>, uint <i>style</i> = Style.Default, int <i>x</i> = 100, int <i>y</i> = 100, GLSettings* <i>gl_settings</i> = null);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Window.this.2"></a>this(Rect <i>rect</i>, string <i>title</i>, Style <i>style</i> = Style.Default, GLSettings* <i>gl_settings</i> = null);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Window.getProjection"></a>inout pure nothrow @nogc ref inout(Matrix4) <u>getProjection</u>();
</big></dt>
<dd>Returns the current projection Matrix
<br><br>
<b>See:</b><br>
Matrix4<br><br>

</dd>
<dt><big><a name="Window.loadProjection"></a>const @nogc void <u>loadProjection</u>();
</big></dt>
<dd>Load the projection Matrix, so that any change / transformation of the Matrix will now be visible<br><br>

</dd>
<dt><big><a name="Window.setClearColor"></a>const nothrow @nogc void <u>setClearColor</u>()(auto ref const Color4b <i>col</i>);
</big></dt>
<dd>Set the color which this windows use to clear the buffer.
 This is also the background color of the window.<br><br>

</dd>
<dt><big><a name="Window.clear"></a>const nothrow @nogc void <u>clear</u>(uint <i>flags</i> = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</big></dt>
<dd>Clears the given buffer (or'ed together)<br><br>

</dd>
<dt><big><a name="Window.setVerticalSync"></a>const nothrow @nogc bool <u>setVerticalSync</u>(Sync <i>sync</i>);
</big></dt>
<dd>Set the Syncronisation mode of this window.
 Default Syncronisation is <code>Sync.Enable</code>.
<br><br>
<b>See:</b><br>
Sync enum
<br><br>

 Returns if the <i>sync</i> mode is supported.<br><br>

</dd>
<dt><big><a name="Window.getVerticalSync"></a>nothrow @nogc Sync <u>getVerticalSync</u>();
</big></dt>
<dd>Returns the current syncronisation mode.
<br><br>
<b>See:</b><br>
Sync enum<br><br>

</dd>
<dt><big><a name="Window.capture"></a>nothrow @nogc Surface <u>capture</u>(Texture.Format <i>fmt</i> = Texture.Format.BGRA);
</big></dt>
<dd>Capture the pixel data of the current window and
 returns a Surface with this pixel data.
 You can also alter the format of the pixel data.
 Default is <code>Texture.Format.BGRA</code>.
 This method is predestinated for screenshots.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Window wnd = ...
...
wnd.<u>capture</u>().saveToFile(<font color=red>"samples/img/screenshot.png"</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Window.hasKeyboardFocus"></a>const nothrow @nogc bool <u>hasKeyboardFocus</u>();
</big></dt>
<dd>Returns if the keyboard focus is on this window.<br><br>

</dd>
<dt><big><a name="Window.hasMouseFocus"></a>const nothrow @nogc bool <u>hasMouseFocus</u>();
</big></dt>
<dd>Returns if the mouse focus is on this window.<br><br>

</dd>
<dt><big><a name="Window.setPosition"></a>nothrow @nogc void <u>setPosition</u>()(auto ref const Vector2i <i>vec</i>);
</big></dt>
<dd>Set a new position to this window<br><br>

</dd>
<dt><big><a name="Window.getPosition"></a>nothrow @nogc Vector2i <u>getPosition</u>();
</big></dt>
<dd>Returns the current position of the window.<br><br>

</dd>
<dt><big><a name="Window.getStyle"></a>nothrow @nogc uint <u>getStyle</u>();
</big></dt>
<dd>Returns the Window Style.
<br><br>
<b>See:</b><br>
Style enum<br><br>

</dd>
<dt><big><a name="Window.poll"></a>const nothrow @nogc bool <u>poll</u>(Event* <i>event</i>);
</big></dt>
<dd>Update the parameter <i>event</i> and set the data of the current <i>event</i> in it.
<br><br>
<b>Returns:</b><br>
<b>true</b>, if there was a valid <i>event</i> and <b>false</b> if not.<br><br>

</dd>
<dt><big><a name="Window.wait"></a>const nothrow @nogc bool <u>wait</u>(Event* <i>event</i>, int <i>timeout</i> = -1);
</big></dt>
<dd>Waits for the given Event.
 If the seconds parameter is greater then -1, it waits maximal <i>timeout</i> seconds.<br><br>

</dd>
<dt><big><a name="Window.push"></a>const nothrow @nogc bool <u>push</u>(Event.Type <i>type</i>);
</big></dt>
<dd>Push an event of the given <i>type</i> inside the Event queue.
<br><br>
<b>Returns:</b><br>
if the <u>push</u> was successfull or not.<br><br>

</dd>
<dt><big><a name="Window.hasEvent"></a>const nothrow @nogc bool <u>hasEvent</u>(Event.Type <i>type</i>);
</big></dt>
<dd><b>Returns:</b><br>
if inside of the Event Queue is an Event of the given <i>type</i>.<br><br>

</dd>
<dt><big><a name="Window.hasQuitEvent"></a>const nothrow @nogc bool <u>hasQuitEvent</u>();
</big></dt>
<dd><b>Returns:</b><br>
if the current Event queue has the Quit Event.<br><br>

</dd>
<dt><big><a name="Window.draw"></a>const nothrow @nogc void <u>draw</u>(Drawable <i>d</i>);
</big></dt>
<dd>Draw a drawable object on screen<br><br>

</dd>
<dt><big><a name="Window.display"></a>nothrow @nogc void <u>display</u>();
</big></dt>
<dd>Make all changes visible on screen<br><br>

</dd>
<dt><big><a name="Window.getTitle"></a>nothrow @nogc string <u>getTitle</u>();
</big></dt>
<dd>Returns the current title of the window.<br><br>

</dd>
<dt><big><a name="Window.setTitle"></a>nothrow @nogc string <u>setTitle</u>(string <i>title</i>);
</big></dt>
<dd>Set a new <i>title</i> to this window
<br><br>
<b>Returns:</b><br>
the old <i>title</i><br><br>

</dd>
<dt><big><a name="Window.setSize"></a>nothrow @nogc void <u>setSize</u>(uint <i>width</i>, uint <i>height</i>);
</big></dt>
<dd>Set a new size to this window<br><br>

</dd>
<dt><big><a name="Window.getSize"></a>nothrow @nogc Size <u>getSize</u>();
</big></dt>
<dd>Returns the size (width and height) of the Window<br><br>

</dd>
<dt><big><a name="Window.setIcon"></a>@nogc void <u>setIcon</u>(ref Surface <i>srfc</i>);
</big></dt>
<dd>Set an icon for this window.<br><br>

</dd>
<dt><big><a name="Window.setFullscreen"></a>nothrow @nogc bool <u>setFullscreen</u>(int <i>style</i>);
</big></dt>
<dd>Use this function to (re)set Window's fullscreen states.
 <i>style</i> may be Style.Fullscreen for "real" fullscreen with a display mode change
 or Style.Desktop for "fake" fullscreen that takes the size of the desktop
 Use 0 for windowed mode.<br><br>

</dd>
<dt><big><a name="Window.toggleFullscreen"></a>nothrow @nogc void <u>toggleFullscreen</u>();
</big></dt>
<dd>Toggle between Fullscreen and windowed mode, depending on the current state.<br><br>

</dd>
<dt><big><a name="Window.isFullscreen"></a>nothrow @nogc bool <u>isFullscreen</u>();
</big></dt>
<dd>Returns, if this Window is in fullscreen mode.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
