<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Dgame.Graphic.Texture</title>
        </head><body>
        <h1>Dgame.Graphic.Texture</h1>
        <!-- Generated by Ddoc from ..\Graphic\Texture.d -->
<br><br>
<dl><dt><big><a name="Texture"></a>struct <u>Texture</u>;
</big></dt>
<dd>A <u>Texture</u> is a 2 dimensional pixel reprasentation.
 It is a wrapper of an OpenGL <u>Texture</u>.
<br><br>
<b>Author:</b><br>
Randy Schuett<br><br>

<dl><dt><big><a name="Texture.Format"></a>enum <u>Format</u>: int;
</big></dt>
<dd>Supported Texture <u>Format</u><br><br>

<dl><dt><big><a name="Texture.Format.None"></a><u>None</u></big></dt>
<dd>Take this if you want to declare that you give no Format.<br><br>

</dd>
<dt><big><a name="Texture.Format.RGB"></a><u>RGB</u></big></dt>
<dd>Alias for GL_RGB<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA"></a><u>RGBA</u></big></dt>
<dd>Alias for GL_RGBA<br><br>

</dd>
<dt><big><a name="Texture.Format.BGR"></a><u>BGR</u></big></dt>
<dd>Alias for GL_BGR<br><br>

</dd>
<dt><big><a name="Texture.Format.BGRA"></a><u>BGRA</u></big></dt>
<dd>Alias for GL_BGRA<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA16"></a><u>RGBA16</u></big></dt>
<dd>16 Bit RGBA Format<br><br>

</dd>
<dt><big><a name="Texture.Format.RGBA8"></a><u>RGBA8</u></big></dt>
<dd>8 Bit RGBA Format<br><br>

</dd>
<dt><big><a name="Texture.Format.Alpha"></a><u>Alpha</u></big></dt>
<dd>Alias for GL_ALPHA<br><br>

</dd>
<dt><big><a name="Texture.Format.Luminance"></a><u>Luminance</u></big></dt>
<dd>Alias for GL_LUMINANCE<br><br>

</dd>
<dt><big><a name="Texture.Format.LuminanceAlpha"></a><u>LuminanceAlpha</u></big></dt>
<dd>Alias for GL_LUMINANCE_ALPHA<br><br>

</dd>
<dt><big><a name="Texture.Format.CompressedRGB"></a><u>CompressedRGB</u></big></dt>
<dd>Compressed RGB<br><br>

</dd>
<dt><big><a name="Texture.Format.CompressedRGBA"></a><u>CompressedRGBA</u></big></dt>
<dd>Compressed RGBA<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture.Compression"></a>enum <u>Compression</u>: int;
</big></dt>
<dd><u>Compression</u> modes<br><br>

<dl><dt><big><a name="Texture.Compression.None"></a><u>None</u></big></dt>
<dd>No compression<br><br>

</dd>
<dt><big><a name="Texture.Compression.DontCare"></a><u>DontCare</u></big></dt>
<dd>The OpenGL implementation decide on their own<br><br>

</dd>
<dt><big><a name="Texture.Compression.Fastest"></a><u>Fastest</u></big></dt>
<dd><u>Fastest</u> compression<br><br>

</dd>
<dt><big><a name="Texture.Compression.Nicest"></a><u>Nicest</u></big></dt>
<dd><u>Nicest</u> but slowest mode of compression<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Texture.this"></a>nothrow @nogc this(void* <i>memory</i>, uint <i>width</i>, uint <i>height</i>, ubyte <i>depth</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.this"></a>nothrow this()(auto ref const Surface <i>srfc</i>);
</big></dt>
<dd>CTor<br><br>

</dd>
<dt><big><a name="Texture.currentlyBound"></a>static nothrow @nogc int <u>currentlyBound</u>();
</big></dt>
<dd>Returns the currently bound texture id.<br><br>

</dd>
<dt><big><a name="Texture.ID"></a>const pure nothrow @nogc @property uint <u>ID</u>();
</big></dt>
<dd>Returns the Texture Id.<br><br>

</dd>
<dt><big><a name="Texture.isValid"></a>const pure nothrow @nogc bool <u>isValid</u>();
</big></dt>
<dd>Returns if the texture is used.<br><br>

</dd>
<dt><big><a name="Texture.width"></a>const pure nothrow @nogc @property uint <u>width</u>();
</big></dt>
<dd>Returns the <u>width</u> of this Texture<br><br>

</dd>
<dt><big><a name="Texture.height"></a>const pure nothrow @nogc @property uint <u>height</u>();
</big></dt>
<dd>Returns the <u>height</u> of this Texture.<br><br>

</dd>
<dt><big><a name="Texture.depth"></a>const pure nothrow @nogc @property ubyte <u>depth</u>();
</big></dt>
<dd>Returns the <u>depth</u>. May often 24 or 32.<br><br>

</dd>
<dt><big><a name="Texture.format"></a>const pure nothrow @nogc @property Format <u>format</u>();
</big></dt>
<dd>Returns the Format.
<br><br>
<b>See:</b><br>
Format enum.<br><br>

</dd>
<dt><big><a name="Texture.bind"></a>const nothrow @nogc void <u>bind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now activated.<br><br>

</dd>
<dt><big><a name="Texture.unbind"></a>const nothrow @nogc void <u>unbind</u>();
</big></dt>
<dd>Binds this Texture.
 Means this Texture is now deactivated.<br><br>

</dd>
<dt><big><a name="Texture.isCurrentlyBound"></a>const nothrow @nogc bool <u>isCurrentlyBound</u>();
</big></dt>
<dd>Returns <b>true</b>, if this Texture is currently activated.<br><br>

</dd>
<dt><big><a name="Texture.setSmooth"></a>pure nothrow @nogc void <u>setSmooth</u>(bool <i>enable</i>);
</big></dt>
<dd>Set smooth filter for the (next) load.<br><br>

</dd>
<dt><big><a name="Texture.isSmooth"></a>const pure nothrow @nogc bool <u>isSmooth</u>();
</big></dt>
<dd>Returns if smooth filter are activated.<br><br>

</dd>
<dt><big><a name="Texture.setRepeat"></a>nothrow @nogc void <u>setRepeat</u>(bool <i>repeat</i>);
</big></dt>
<dd>Set repeating for the (next) load.<br><br>

</dd>
<dt><big><a name="Texture.isRepeated"></a>const pure nothrow @nogc bool <u>isRepeated</u>();
</big></dt>
<dd>Returns if repeating is enabled.<br><br>

</dd>
<dt><big><a name="Texture.setCompression"></a>pure nothrow @nogc void <u>setCompression</u>(Compression <i>comp</i>);
</big></dt>
<dd>(Re)Set the compression mode.
<br><br>
<b>See:</b><br>
Compression enum<br><br>

</dd>
<dt><big><a name="Texture.getCompression"></a>const pure nothrow @nogc Compression <u>getCompression</u>();
</big></dt>
<dd>Returns the current Compression mode.
<br><br>
<b>See:</b><br>
Compression enum<br><br>

</dd>
<dt><big><a name="Texture.isCompressed"></a>const nothrow @nogc bool <u>isCompressed</u>();
</big></dt>
<dd>Checks whether the current Texture is compressed or not.<br><br>

</dd>
<dt><big><a name="Texture.loadFrom"></a>nothrow @nogc void <u>loadFrom</u>()(auto ref const Surface <i>srfc</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Load from Surface<br><br>

</dd>
<dt><big><a name="Texture.loadFromMemory"></a>nothrow @nogc void <u>loadFromMemory</u>(void* <i>memory</i>, uint <i>width</i>, uint <i>height</i>, ubyte <i>depth</i>, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Load from <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Texture.setColorkey"></a>nothrow @nogc void <u>setColorkey</u>()(auto ref const Color4b <i>colorkey</i>);
</big></dt>
<dd>Set a colorkey.<br><br>

</dd>
<dt><big><a name="Texture.getMemory"></a>const nothrow @nogc void[] <u>getMemory</u>(void[] <i>memory</i>);
</big></dt>
<dd>Returns the pixel of this Texture or <b>null</b> if this Texture isn't valid.
 If <i>memory</i> is not <b>null</b> and has the same width and height as the Texture,
 it is used to store the pixel data.
 Otherwise it <b>allocates</b> GC <i>memory</i>.<br><br>

</dd>
<dt><big><a name="Texture.getMemory"></a>const nothrow void[] <u>getMemory</u>();
</big></dt>
<dd>Returns the pixel of this Texture or <b>null</b> if this Texture isn't valid.
 If memory is not <b>null</b> and has the same width and height as the Texture,
 it is used to store the pixel data.
 Otherwise it <b>allocates</b> GC memory.<br><br>

</dd>
<dt><big><a name="Texture.subTexture"></a>const nothrow @nogc Texture <u>subTexture</u>()(auto ref const Rect <i>rect</i>);
</big></dt>
<dd>Returns a <u>subTexture</u> of this Texture.<br><br>

</dd>
<dt><big><a name="Texture.copy"></a>const nothrow @nogc void <u>copy</u>(ref const Texture <i>tex</i>, const Rect* <i>rect</i> = null);
</big></dt>
<dd>Copy another Texture to this.
 The second parameter is a pointer to the destination <i>rect</i>.
 Is it is <b>null</b> this means the whole <i>tex</i> is copied.<br><br>

</dd>
<dt><big><a name="Texture.update"></a>const nothrow @nogc void <u>update</u>(const void* <i>memory</i>, const Rect* <i>rect</i> = null, Format <i>fmt</i> = Format.None);
</big></dt>
<dd>Update the pixel data of this Texture.
 The second parameter is a pointer to the area which is updated.
 If it is <b>null</b> (default) the whole Texture will be updated.
 The third parameter is the format of the pixels.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="formatToBits"></a>pure nothrow @nogc ubyte <u>formatToBits</u>(Texture.Format <i>fmt</i>);
</big></dt>
<dd>Format a Texture.Format into the related bit count.
 If the format is not supported, it returns 0.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGBA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.RGB) == 24);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGRA) == 32);
<font color=blue>assert</font>(<u>formatToBits</u>(Texture.Format.BGR) == 24);
</pre>
<br><br>

</dd>
<dt><big><a name="bitsToFormat"></a>pure nothrow @nogc Texture.Format <u>bitsToFormat</u>(ubyte <i>bits</i>, bool <i>reverse</i> = false);
</big></dt>
<dd>Format a bit count into the related Texture.Format.
 If no bit count is supported, it returns Texture.Format.None.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>bitsToFormat</u>(32) == Texture.Format.RGBA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24) == Texture.Format.RGB);
<font color=blue>assert</font>(<u>bitsToFormat</u>(32, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>bitsToFormat</u>(24, <font color=blue>true</font>) == Texture.Format.BGR);
</pre>
<br><br>

</dd>
<dt><big><a name="switchFormat"></a>pure nothrow @nogc Texture.Format <u>switchFormat</u>(Texture.Format <i>fmt</i>, bool <i>alpha</i> = false);
</big></dt>
<dd>Switch/Reverse Texture.Format.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB) == Texture.Format.BGR);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGB, <font color=blue>true</font>) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA) == Texture.Format.BGRA);
<font color=blue>assert</font>(<u>switchFormat</u>(Texture.Format.RGBA, <font color=blue>true</font>) == Texture.Format.BGRA);
</pre>
<br><br>

</dd>
<dt><big><a name="compressFormat"></a>pure nothrow @nogc Texture.Format <u>compressFormat</u>(Texture.Format <i>fmt</i>);
</big></dt>
<dd>Choose the right compress format for the given Texture.Format.
<br><br>
<b>See:</b><br>
Texture.Format enum<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
