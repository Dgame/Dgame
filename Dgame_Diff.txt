diff --git a/Audio/Internal/core.d b/Audio/Internal/core.d
index abf6a4f..47f73c6 100644
--- a/Audio/Internal/core.d
+++ b/Audio/Internal/core.d
@@ -17,7 +17,7 @@ private:
 private {
 	debug import std.stdio : writeln;
 	
-	AL _myAl;
+	AL _myAl = void;
 
 	void _alError(string msg) {
 		debug switch (alcGetError(_myAl.device)) {
diff --git a/Audio/Sound.d b/Audio/Sound.d
index 6ee227b..8dfdeda 100644
--- a/Audio/Sound.d
+++ b/Audio/Sound.d
@@ -142,7 +142,6 @@ final:
 	 */
 	this() {
 		this._alChunk.init();
-		
 		this._status = Status.None;
 		
 		_ALFinalizer ~= &this._alChunk;
@@ -224,11 +223,10 @@ final:
 		assert(soundfile !is null, "Soundfile is null.");
 	} body {
 		const SoundFile* sFile = &soundfile.getData();
-		
 		this._soundfile = soundfile;
 		
 		/// Load
-		Channel ch;
+		Channel ch = void;
 		switch (sFile.bits) {
 			case 8:
 				if (sFile.channels == 1)
@@ -331,7 +329,7 @@ final:
 	/**
 	 * Returns the soundfile.
 	 */
-	final ref BaseSoundFile getSoundFile() {
+	final BaseSoundFile getSoundFile() {
 		return this._soundfile;
 	}
 	
diff --git a/Audio/SoundFile.d b/Audio/SoundFile.d
index 2b65b2a..addfb05 100644
--- a/Audio/SoundFile.d
+++ b/Audio/SoundFile.d
@@ -7,7 +7,6 @@ package import core.stdc.stdio : FILE, fopen, fseek, fread, fclose, SEEK_SET;
  * A helper struct for reading from a sound file.
  */
 struct SoundFile {
-public:
 	char[4] type;		/** Sound type. e.g. 'wave', 'ogg' */
 	string filename;	/** Sound filename */
 	byte[] buffer;		/** Buffer */
@@ -15,10 +14,11 @@ public:
 	uint rate;			/** The sound rate */
 	uint dataSize;		/** Total data size */
 	
-	int channels;	/** Number of channels */
-	ubyte bits;		/** Number of bits */
+	int channels;		/** Number of channels */
+	ubyte bits;			/** Number of bits */
 	ubyte bytes;		/** Number of bytes */
-	
+
+
 	@disable
 	this(this);
 }
@@ -42,7 +42,7 @@ enum MusicType : ubyte {
  */
 abstract class BaseSoundFile {
 protected:
-	SoundFile _sFile;
+	SoundFile _sFile = void;
 	
 	abstract void _read(string filename);
 	
@@ -51,9 +51,8 @@ public:
 	 * CTor
 	 */
 	this(string filename) {
-		if (!exists(filename)) {
+		if (!exists(filename))
 			throw new Exception("File " ~ filename ~ " does not exists.");
-		}
 		
 		this._read(filename);
 	}
@@ -62,7 +61,7 @@ public:
 	 * Free/delete the memory buffer.
 	 */
 	final void freeBuffer() {
-		.destroy(_sFile.buffer);
+		_sFile.buffer = null;
 	}
 	
 	/**
diff --git a/Audio/VorbisFile.d b/Audio/VorbisFile.d
index f8ba5d2..acef8d1 100644
--- a/Audio/VorbisFile.d
+++ b/Audio/VorbisFile.d
@@ -28,17 +28,17 @@ protected:
 	override void _read(string filename) {
 		scope(failure) throw new Exception("It seems that is not a valid ogg/vorbis file.");
 		
-		_sFile.filename = filename;
+		super._sFile.filename = filename;
 		
-		FILE* fp = fopen(filename.ptr, "rb");
-		fread(&_sFile.type, char.sizeof, 4, fp);
+		FILE* fp = fopen(filename.ptr, "rb".ptr);
+		fread(&super._sFile.type, char.sizeof, 4, fp);
 		
-		if (_sFile.type != "OggS")
+		if (super._sFile.type != "OggS")
 			throw new Exception("Missing OggS");
 		
 		fseek(fp, 0, SEEK_SET); // Set to the file beginning
 		
-		OggVorbis_File oggFile;
+		OggVorbis_File oggFile = void;
 		
 		if (ov_open(fp, &oggFile, null, 0) < 0)
 			throw new Exception(filename ~ " is no valid Vorbis file.");
@@ -46,23 +46,21 @@ protected:
 		// Get some information about the OGG file
 		vorbis_info* pInfo = ov_info(&oggFile, -1);
 		
-		_sFile.rate  = pInfo.rate;
-		_sFile.bits  = 16;
-		_sFile.bytes = 2;
-		_sFile.dataSize = cast(uint) ov_pcm_total(&oggFile, -1) * _sFile.bytes * pInfo.channels;
-		_sFile.channels = pInfo.channels;
+		super._sFile.rate  = pInfo.rate;
+		super._sFile.bits  = 16;
+		super._sFile.bytes = 2;
+		super._sFile.dataSize = cast(uint) ov_pcm_total(&oggFile, -1) * super._sFile.bytes * pInfo.channels;
+		super._sFile.channels = pInfo.channels;
 		debug writefln("Allocate %d memory for Vorbis.", _sFile.dataSize);
-		_sFile.buffer = new byte[_sFile.dataSize];
+		super._sFile.buffer = new byte[super._sFile.dataSize];
 		
-		uint current = 0;
-		int endian   = 0; // 0 for Little-Endian, 1 for Big-Endian
+		uint current;
+		int endian = 0; // 0 for Little-Endian, 1 for Big-Endian
 		int bitStream;
-		
 		long bytes;
-		while (current < _sFile.dataSize) { // because it may take several requests to fill our buffer
-			bytes = ov_read(&oggFile,
-			                _sFile.buffer[current .. $].ptr,
-			_sFile.dataSize - current, endian, 2, 1, &bitStream);
+
+		while (current < super._sFile.dataSize) { // because it may take several requests to fill our buffer
+			bytes = ov_read(&oggFile, super._sFile.buffer[current .. $].ptr, super._sFile.dataSize - current, endian, 2, 1, &bitStream);
 			
 			current += bytes;
 		}
diff --git a/Audio/WaveFile.d b/Audio/WaveFile.d
index 7801a65..bbb3e70 100644
--- a/Audio/WaveFile.d
+++ b/Audio/WaveFile.d
@@ -19,9 +19,9 @@ protected:
 	override void _read(string filename) {
 		//scope(failure) throw new Exception("It seems that is not a valid wave file: " ~ to!string(alGetError()));
 		
-		_sFile.filename = filename;
+		super._sFile.filename = filename;
 		
-		FILE* fp = fopen(filename.ptr, "rb");
+		FILE* fp = fopen(filename.ptr, "rb".ptr);
 		
 		char[4] buf;
 		fread(&buf, char.sizeof, 4, fp);
@@ -29,9 +29,9 @@ protected:
 			throw new Exception("No Riff");
 		
 		fread(&buf, uint.sizeof, 1, fp);
-		fread(&_sFile.type, char.sizeof, 4, fp);
+		fread(&super._sFile.type, char.sizeof, 4, fp);
 		
-		if (_sFile.type != "WAVE")
+		if (super._sFile.type != "WAVE")
 			throw new Exception("No WAVE");
 		
 		fread(&buf, char.sizeof, 4, fp);
@@ -44,23 +44,23 @@ protected:
 		
 		fread(&chunkSize, uint.sizeof, 1, fp);
 		fread(&formatType, short.sizeof, 1, fp);
-		fread(&_sFile.channels, short.sizeof, 1, fp);
-		fread(&_sFile.rate, uint.sizeof, 1, fp);
+		fread(&super._sFile.channels, short.sizeof, 1, fp);
+		fread(&super._sFile.rate, uint.sizeof, 1, fp);
 		fread(&avgBytesPerSec, uint.sizeof, 1, fp);
-		fread(&_sFile.bytes, short.sizeof, 1, fp);
-		fread(&_sFile.bits, short.sizeof, 1, fp);
+		fread(&super._sFile.bytes, short.sizeof, 1, fp);
+		fread(&super._sFile.bits, short.sizeof, 1, fp);
 		
 		fread(&buf, char.sizeof, 4, fp);
 		if (buf != "data")
 			throw new Exception("Missing DATA");
 		
-		fread(&_sFile.dataSize, uint.sizeof, 1, fp);
-		debug writefln("Allocate %d memory for Wave.", _sFile.dataSize);
-		_sFile.buffer = new byte[_sFile.dataSize];
+		fread(&super._sFile.dataSize, uint.sizeof, 1, fp);
+		debug writefln("Allocate %d memory for Wave.", super._sFile.dataSize);
+		super._sFile.buffer = new byte[super._sFile.dataSize];
 		
-		assert(_sFile.buffer !is null);
-		fread(_sFile.buffer.ptr, byte.sizeof, _sFile.dataSize, fp);
-		assert(_sFile.buffer !is null);
+		debug assert(super._sFile.buffer !is null);
+		fread(super._sFile.buffer.ptr, byte.sizeof, super._sFile.dataSize, fp);
+		debug assert(super._sFile.buffer !is null);
 		
 		fclose(fp);
 		fp = null;
diff --git a/Dokumentation/Allocator.html b/Dokumentation/Allocator.html
index ee42fd0..2716066 100644
--- a/Dokumentation/Allocator.html
+++ b/Dokumentation/Allocator.html
@@ -4,7 +4,10 @@
         </head><body>
         <h1>Dgame.Internal.Allocator</h1>
         <!-- Generated by Ddoc from Internal\Allocator.d -->
+@file
 <br><br>
+allocator class.<br><br>
+
 
         <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
         </body></html>
diff --git a/Dokumentation/Sound.html b/Dokumentation/Sound.html
index fd5fc63..9acfb97 100644
--- a/Dokumentation/Sound.html
+++ b/Dokumentation/Sound.html
@@ -162,7 +162,7 @@ WaveFile<br><br>
 <dd>Load from memory.<br><br>
 
 </dd>
-<dt><big><a name="Sound.getSoundFile"></a>final ref BaseSoundFile <u>getSoundFile</u>();
+<dt><big><a name="Sound.getSoundFile"></a>final BaseSoundFile <u>getSoundFile</u>();
 </big></dt>
 <dd>Returns the soundfile.<br><br>
 
diff --git a/Graphics/Shape.d b/Graphics/Shape.d
index 18d8755..ab118ea 100644
--- a/Graphics/Shape.d
+++ b/Graphics/Shape.d
@@ -7,6 +7,8 @@ private {
 	
 	import derelict.opengl3.gl;
 
+	import Dgame.Internal.Array;
+
 	import Dgame.Graphics.Color;
 	import Dgame.Graphics.Drawable;
 	import Dgame.Graphics.Transformable;
diff --git a/Graphics/Surface.d b/Graphics/Surface.d
index 156d62c..57623b9 100644
--- a/Graphics/Surface.d
+++ b/Graphics/Surface.d
@@ -204,8 +204,9 @@ public:
 		debug writefln("Load Image: %s", filename);
 		SDL_Surface* srfc = IMG_Load(toStringz(filename));
 		debug writefln("Image %s loaded :: %X", filename, srfc);
+
 		if (srfc is null)
-			throw new Exception("Could not load image " ~ filename ~ ". Error: " ~ to!string(SDL_GetError()));
+			throw new Exception(.format("Could not load image %s. Error: %s.", filename, to!string(SDL_GetError())));
 		
 		this._target = make_shared(srfc, (SDL_Surface* ptr) => SDL_FreeSurface(ptr));
 		
@@ -225,8 +226,7 @@ public:
 			RMask, GMask, BMask, AMask);
 		
 		if (srfc is null)
-			throw new Exception("Could not load image. Error: "
-								~ to!string(SDL_GetError()));
+			throw new Exception("Could not load image. Error: " ~ to!string(SDL_GetError()));
 		
 		this._target = make_shared(srfc, (SDL_Surface* ptr) => SDL_FreeSurface(ptr));
 	}
@@ -235,13 +235,11 @@ public:
 	 * Save the current pixel data to the file.
 	 */
 	void saveToFile(string filename) {
-		if (filename.length < 3)
+		if (filename.length < 4)
 			throw new Exception("File name is not allowed.");
 		
-		if (SDL_SaveBMP(this.ptr, toStringz(filename)) != 0) {
-			throw new Exception("Could not save image " ~ filename ~ ". Error: "
-								~ to!string(SDL_GetError()));
-		}
+		if (SDL_SaveBMP(this.ptr, toStringz(filename)) != 0)
+			throw new Exception(.format("Could not save image %s. Error: %s.", filename, to!string(SDL_GetError())));
 	}
 	
 	/**
diff --git a/Graphics/Text.d b/Graphics/Text.d
index ab5616d..5e10b97 100644
--- a/Graphics/Text.d
+++ b/Graphics/Text.d
@@ -77,8 +77,10 @@ private:
 		
 		SDL_Color* fg = this._fg.ptr;
 		SDL_Color* bg = this._bg.ptr;
+
+		const Font.Mode fmode = this._font.getMode();
 		
-		final switch (this._font.getMode()) {
+		final switch (fmode) {
 			case Font.Mode.Solid:
 				srfc = TTF_RenderUTF8_Solid(this._font.ptr, cstr, *fg);
 				break;
@@ -92,7 +94,7 @@ private:
 		
 		assert(srfc !is null, "Surface is null.");
 		
-		if (this._font.getMode() != Font.Mode.Blended) {
+		if (fmode != Font.Mode.Blended) {
 			/// Adapt PixelFormat
 			SDL_PixelFormat fmt;
 			fmt.BitsPerPixel = 24;
diff --git a/Graphics/TileMap.d b/Graphics/TileMap.d
index 7cb1300..c82e033 100644
--- a/Graphics/TileMap.d
+++ b/Graphics/TileMap.d
@@ -9,6 +9,8 @@ private {
 	
 	import derelict.opengl3.gl;
 	import derelict.sdl2.sdl;
+
+	import Dgame.Internal.Array;
 	
 	import Dgame.Math.Vector2;
 	import Dgame.Math.Rect;
@@ -171,7 +173,7 @@ private:
 	void _readTileMap() {
 		Document doc = new Document(cast(string) .read(this._filename));
 		
-		vec3f[] vertices;
+		array!vec3f vertices;
 		
 		foreach (const Element elem; doc.elements) {
 			if (elem.tag.name == "tileset") {
@@ -244,15 +246,14 @@ private:
 	}
 	
 	void _loadTileset() in {
-		assert(this._tmi.tileWidth == this._tmi.tileHeight,
-		       "Tile dimensions must be equal.");
+		assert(this._tmi.tileWidth == this._tmi.tileHeight, "Tile dimensions must be equal.");
 	} body {
 		SubSurface[] subs;
 		
 		ushort[2][ushort] used;
 		ushort[2]*[] coordinates;
 		
-		uint doubly = 0;
+		//uint doubly = 0;
 		
 		Surface tileset = Surface(this._tmi.source);
 		ShortRect src = ShortRect(0, 0, this._tmi.tileWidth, this._tmi.tileHeight);
@@ -266,8 +267,8 @@ private:
 					src.setPosition(used[t.gid][0], used[t.gid][1]); /// TODO: May Fixed in 2.064?
 					subs ~= SubSurface(tileset.subSurface(src), t.gid);
 				}
-			} else
-				doubly++;
+			}/* else
+				doubly++;*/
 			
 			coordinates ~= &used[t.gid];
 		}
@@ -278,9 +279,7 @@ private:
 		this._loadTexCoords(coordinates);
 	}
 	
-	void _compress(ref Surface tileset,
-	               ref ushort[2][ushort] used, ref SubSurface[] subs)
-	{
+	void _compress(ref Surface tileset, ushort[2][ushort] used, SubSurface[] subs) {
 		if (this._doCompress) {
 			const ushort dim = calcDim(used.length, this._tmi.tileWidth);
 			
@@ -333,9 +332,9 @@ private:
 		}
 	}
 	
-	void _loadTexCoords(ref ushort[2]*[] coordinates) {
+	void _loadTexCoords(ushort[2]*[] coordinates) {
 		/// Sammeln der Textur Koordinaten
-		vec2f[] texCoords;
+		array!vec2f texCoords;
 		texCoords.reserve(coordinates.length * 4);
 		
 		debug writefln("TileMap: Reserve %d texCoords (%d).",
diff --git a/Internal/Allocator.d b/Internal/Allocator.d
index 18dbd8b..f341745 100644
--- a/Internal/Allocator.d
+++ b/Internal/Allocator.d
@@ -1,92 +1,136 @@
+/**
+ * @file 
+ *
+ * allocator class.
+ */
 module Dgame.Internal.Allocator;
 
 private {
-	debug import std.stdio : writefln;
+	debug import std.stdio;
 	import core.stdc.stdlib : malloc, free;
 }
 
-struct ScopeAllocator {
-private:
-	enum Limit = 8;
-
-	void*[Limit] _memory;
-	int _counter;
+struct Type(T, const size_t StackSize = 4096 / T.sizeof) {
+	static {
+		T[StackSize] StackBuffer = void;
+		size_t StackLength;
+	}
 
-public:
-	@disable
-	this(this);
+	/**
+	 * This structure represents a Variable Length Array as you may known from C99.
+	 *
+	 * @author: Besitzer
+	 * @date: 27.10.2013
+	 */
+	static struct Vala {
+		T* ptr;
+		const size_t length;
+		const bool onHeap;
+
+		@disable
+		this(this);
+
+		~this() {
+			debug writeln("DTor Vala");
+			debug writeln("StackLength: ", StackLength);
+
+			if (!this.onHeap)
+				StackLength -= this.length;
+			else if (this.ptr !is null) {
+				debug writefln("Deallocate %d elements.", this.length);
+
+				.free(this.ptr);
+			}
+		}
 
-	~this() {
-		this.collect();
-	}
+		inout(T[]) opSlice() inout {
+			return this.ptr[0 .. this.length];
+		}
 
-	void collect() {
-		debug writefln("Collect all (%d objects)", this._counter);
+		void opSliceAssign(T item) {
+			for (size_t i = 0; i < this.length; ++i) {
+				this.ptr[i] = item;
+			}
+		}
 
-		for (size_t i = 0; i < this._memory.length; ++i) {
-			if (this._memory[i] is null)
-				continue;
+		void opSliceAssign(T[] items) {
+			const size_t len = this.length > items.length ? items.length : this.length;
+			for (size_t i = 0; i < len; ++i) {
+				this.ptr[i] = items[i];
+			}
+		}
 
-			free(this._memory[i]);
-			this._memory[i] = null;
+		void opSliceOpAssign(string op)(T item) {
+			for (size_t i = 0; i < this.length; ++i) {
+				mixin("this.ptr[i] " ~ op ~ "= item;");
+			}
 		}
 
-		this._counter = 0;
+		alias ptr this;
 	}
 
-	T[] allocate(T = void)(size_t N) {
-		debug writefln("Allocate the %d object with N = %d.", this._counter + 1, N);
-
-		if (this.remain() == 0)
-			throw new Exception("Reached MemoryPool limit.");
+	/**
+	 * This is the start method to initialize a Variable Length Array.
+	 *
+	 * @author: Besitzer
+	 * @date: 27.10.2013
+	 */
+	static Vala opIndex(size_t N) {
+		if ((StackLength + N) <= StackSize) {
+			debug writefln("Allocate %d elements on the stack.", N);
+			scope(exit) StackLength += N;
+
+			return Vala(&StackBuffer[StackLength], N, false);
+		}
 
-		this._memory[this._counter] = malloc(N * T.sizeof);
-		scope(exit) this._counter++;
+		debug writefln("Allocate %d elements on the heap.", N);
 
-		return (cast(T*) this._memory[this._counter])[0 .. N];
+		return Vala(cast(T*) .malloc(N * T.sizeof), N, true);
 	}
+}
 
-	bool deallocate(ref void* ptr) {
-		debug writefln("Deallocate an object (%d remain)", this._counter - 1);
+unittest {
+	int n = 128;
+	auto t = Type!int[n];
 
-		size_t i = 0;
-		for ( ; i < Limit; ++i) {
-			if (this._memory[i] == ptr) {
-				free(this._memory[i]);
+	assert(t.length == n);
+	assert(t.onHeap == false);
 
-				this._memory[i] = null;
-				ptr = null;
+	int[] arr = t[];
+	assert(arr.length == n);
 
-				this._counter--;
+	t[0] = 42;
+	assert(arr[0] == t[0] && t[0] == 42);
 
-				if (i != this._counter && this._counter >= 0) {
-					auto tmp = this._memory[this._counter];
-					this._memory[i] = tmp;
-					this._memory[this._counter] = null;
-				}
+	ushort w = 1024;
+	ushort h = 640;
 
-				break;
-			}
-		}
+	auto foo1 = Type!ubyte[w * h * 4];
+	assert(foo1.length == w * h * 4);
+	assert(foo1.onHeap == true);
 
-		if (i < this._memory.length) {
-			debug writefln("\tDeallocated the %d object.", i + 1);
+	auto foo2 = Type!ubyte[w * 4];
+	assert(foo2.length == w * 4);
+	assert(foo2.onHeap == false);
 
-			return true;
-		}
+	auto test1 = Type!int[512];
+	assert(test1.length == 512);
+	assert(test1.onHeap == false);
+	assert(test1[0] != 42);
 
-		return false;
-	}
+	test1[42] = 1337;
 
-	int count() const pure nothrow {
-		return this._counter;
-	}
+	assert(Type!int.StackLength == 640);
 
-	ushort remain() const pure nothrow {
-		// to avoid a cast...
-		ushort max = Limit;
-		max -= this._counter;
+	auto test2 = Type!int[384];
+	assert(test2.length == 384);
+	assert(test2.onHeap == false);
 
-		return max;
-	}
+	assert(test2[0] != 42 && test2[42] != 1337);
+
+	auto test3 = Type!int[256];
+	assert(test3.length == 256);
+	assert(test3.onHeap == true);
+
+	assert(test3[0] != 42 && test3[42] != 1337);
 }
\ No newline at end of file
diff --git a/Math/Rect.d b/Math/Rect.d
index fae94c4..5cbbd1b 100644
--- a/Math/Rect.d
+++ b/Math/Rect.d
@@ -6,7 +6,7 @@ private {
 	
 	import derelict.sdl2.sdl;
 	
-	import Dgame.Internal.Allocator : ScopeAllocator;
+	import Dgame.Internal.Allocator : Type;
 	import Dgame.Math.Vector2;
 }
 
@@ -236,8 +236,7 @@ public:
 	 * Use this function to calculate a minimal rectangle enclosing a set of points.
 	 */
 	static Rect!T enclosePoints(const Vector2!T[] points) {
-		ScopeAllocator m;
-		SDL_Point[] sdl_points = m.allocate!SDL_Point(points.length);
+		auto sdl_points = Type!SDL_Point[points.length];
 		
 		foreach (i, ref const Vector2!T p; points) {
 			sdl_points[i] = SDL_Point(cast(int) p.x, cast(int) p.y);
diff --git a/System/VertexBufferObject.d b/System/VertexBufferObject.d
index 6610cad..f45d30a 100644
--- a/System/VertexBufferObject.d
+++ b/System/VertexBufferObject.d
@@ -117,11 +117,10 @@ private:
 	
 	Primitive.Target _curTarget;
 	
-	const ubyte _targetNums;
-	const ubyte[Primitive.Target] _targetIds;
-	
+	/*const */ubyte _targetNums;
+	/*const */ubyte[Primitive.Target] _targetIds;
 	bool[Primitive.Target] _dataAssigned;
-	
+
 public:
 	/**
 	 * CTor
@@ -132,19 +131,18 @@ public:
 		
 		this.type = type;
 		this.targets = trg;
-		
-		ubyte num = 0;
+
+		this._targetNums = 0;
 		if (Primitive.Target.Vertex & trg)
-			this._targetIds[Primitive.Target.Vertex] = num++;
+			this._targetIds[Primitive.Target.Vertex] = this._targetNums++;
 		if (Primitive.Target.Color & trg)
-			this._targetIds[Primitive.Target.Color] = num++;
+			this._targetIds[Primitive.Target.Color] = this._targetNums++;
 		if (Primitive.Target.TexCoords & trg)
-			this._targetIds[Primitive.Target.TexCoords] = num++;
-		
-		this._targetNums = num;
+			this._targetIds[Primitive.Target.TexCoords] = this._targetNums++;
+
 		this._curTarget = Primitive.Target.None;
 		
-		glGenBuffers(num, &this._vboId[0]);
+		glGenBuffers(this._targetNums, &this._vboId[0]);
 		
 		foreach (Primitive.Target id, _; this._targetIds) {
 			this.bind(id);
diff --git a/Window/Window.d b/Window/Window.d
index 4839dec..a7caa0a 100644
--- a/Window/Window.d
+++ b/Window/Window.d
@@ -6,7 +6,7 @@ private {
 	import derelict.sdl2.sdl;
 	import derelict.opengl3.gl;
 	
-	import Dgame.Internal.Allocator : ScopeAllocator;
+	import Dgame.Internal.Allocator : Type;
 
 	import Dgame.Graphics.Color;
 	import Dgame.Graphics.Drawable;
@@ -95,10 +95,7 @@ public:
 	/**
 	 * CTor
 	 */
-	this(VideoMode videoMode, string title = DefaultTitle,
-	     Style style = Window.Style.Default,
-	     short x = DefaultXPos, short y = DefaultYPos)
-	{
+	this(VideoMode videoMode, string title = DefaultTitle, Style style = Window.Style.Default, short x = DefaultXPos, short y = DefaultYPos) {
 		/// Create an application window with the following settings:
 		this._window = SDL_CreateWindow(title.ptr,	///    const char* title
 		                                x,	///    int x: initial x position
@@ -111,11 +108,6 @@ public:
 			throw new Exception("Error by creating a SDL2 window: " ~ to!string(SDL_GetError()));
 		
 		if (style & Style.OpenGL) {
-			SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 3);
-			SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 3);
-			SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 2);
-			SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 0);
-			SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);
 			SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
 			SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
 			
@@ -175,9 +167,9 @@ public:
 		if (this._window is null && this._glContext is null)
 			return;
 
-		/// Once finished with OpenGL functions, the SDL_GLContext can be deleted.
+		// Once finished with OpenGL functions, the SDL_GLContext can be deleted.
 		SDL_GL_DeleteContext(this._glContext);  
-		/// Close and destroy the window
+		// Close and destroy the window
 		SDL_DestroyWindow(this._window);
 		
 		this._glContext = null;
@@ -260,18 +252,15 @@ public:
 	 * ----
 	 */
 	Surface capture(Texture.Format fmt = Texture.Format.BGRA) const {
-		Surface _capture = Surface.make(this.width, this.height);
+		Surface mycapture = Surface.make(this.width, this.height);
 		
-		ubyte* pixels = cast(ubyte*) _capture.getPixels();
-		glReadPixels(0, 0, this.width, this.height,
-		             fmt, GL_UNSIGNED_BYTE, pixels);
+		ubyte* pixels = cast(ubyte*) mycapture.getPixels();
+		glReadPixels(0, 0, this.width, this.height, fmt, GL_UNSIGNED_BYTE, pixels);
 		
 		const uint lineWidth = this.width * 4;
 		const uint hlw = this.height * lineWidth;
 		
-		ScopeAllocator m;
-		ubyte[] tmpLine = m.allocate!ubyte(lineWidth);
-
+		auto tmpLine = Type!ubyte[lineWidth];
 		debug writeln("Screenshot alloc: ", tmpLine.length, "::", lineWidth);
 		
 		for (uint i = 0; i < this.height / 2; ++i) {
@@ -284,11 +273,11 @@ public:
 			tmpLine[] = pixels[tmpIdx1 .. tmpIdx2];
 			ubyte[] switchLine = pixels[switchIdx1 .. switchIdx2];
 			
-			pixels[tmpIdx1 .. tmpIdx2][] = switchLine[];
-			pixels[switchIdx1 .. switchIdx2][] = tmpLine[];
+			pixels[tmpIdx1 .. tmpIdx2] = switchLine[];
+			pixels[switchIdx1 .. switchIdx2] = tmpLine[];
 		}
 		
-		return _capture;
+		return mycapture;
 	}
 	
 	/**
diff --git a/main.d b/main.d
index da775b4..46c9745 100644
--- a/main.d
+++ b/main.d
@@ -7,14 +7,14 @@ import Dgame.System.all;
 
 import Dgame.System.FrameBufferObject;
 
-//pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict2\\lib\\DerelictGL.lib");
-//pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict2\\lib\\DerelictUtil.lib");
-
-pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\DerelictSDL2.lib");
-pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\DerelictUtil.lib");
-pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\DerelictGL3.lib");
-pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\DerelictAL.lib");
-pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\DerelictOGG.lib");
+//pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict2\\lib\\dmd\\DerelictGL.lib");
+//pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict2\\lib\\dmd\\DerelictUtil.lib");
+
+pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\dmd\\DerelictSDL2.lib");
+pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\dmd\\DerelictUtil.lib");
+pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\dmd\\DerelictGL3.lib");
+pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\dmd\\DerelictAL.lib");
+pragma(lib, "D:\\D\\dmd2\\src\\ext\\derelict\\lib\\dmd\\DerelictOGG.lib");
 
 import Dgame.Internal.core : getDgVersion;
 
